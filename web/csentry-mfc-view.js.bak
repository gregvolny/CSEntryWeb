/**
 * CSEntry MFC-Style Web Component
 * 
 * A web component that replicates the classic Windows MFC CSEntry interface.
 * This provides a traditional form-based view with case tree, form canvas,
 * and CAPI panel, similar to the desktop Windows application.
 * 
 * @example
 * <csentry-mfc-view
 *   pff-url="./survey.pff"
 *   operator-id="OPERATOR">
 * </csentry-mfc-view>
 */

class CSEntryMFCView extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        
        // State
        this.engine = null;
        this.formRenderer = null;
        this.capiRenderer = null;
        this.caseTreeRenderer = null;
        this.currentApp = null;
        this.currentForm = null;
        this.currentField = null;
        this.fieldIndex = -1;
        this.operatorId = 'OPERATOR';
        
        // Engine execution mode
        this._useServerSide = false;     // True if using server-side REST API
        this._serverSessionId = null;    // Server session ID when using REST API
        this._wasmModule = null;         // Emscripten module reference
        
        // Navigation state - tracks all navigable fields in form order
        this.navigationFields = [];  // Flat list of all fields in navigation order
        this.currentNavIndex = -1;   // Current position in navigation
        this.isPathOn = true;        // System-controlled path (like CSEntry)
        
        // Layout state
        this.leftPanelWidth = 250;
        this.isResizing = false;
        
        // Dialog state for CSPro native dialogs
        this._dialogResolve = null;
        this._dialogInputData = null;
        
        // Initialize modular handlers
        this._csproLogicHandler = null;
        this._questionTextHandler = null;
        
        // Setup CSProDialogHandler for WASM engine dialog callbacks
        this._setupCSProDialogHandler();
        
        this._render();
    }

    static get observedAttributes() {
        return ['pff-url', 'operator-id', 'theme', 'show-capi', 'show-tree'];
    }

    connectedCallback() {
        this._setupEventListeners();
        this._cacheDialogElements();
        this._setupCapiMessageListener();
        this._initCaptureDisplayMode();
        this._initializeHandlers();
        
        // Check for initial PFF URL
        const pffUrl = this.getAttribute('pff-url');
        if (pffUrl) {
            this.loadApplication(pffUrl);
        }
    }
    
    /**
     * Initialize modular handlers for CSPro logic and question text
     */
    async _initializeHandlers() {
        try {
            // Dynamically import handlers
            const { createCSProLogicHandler } = await import('./components/csentry-mfc-view/handlers/cspro-logic-handler.js');
            const { createQuestionTextHandler } = await import('./components/csentry-mfc-view/handlers/question-text-handler.js');
            
            this._csproLogicHandler = createCSProLogicHandler(this);
            this._questionTextHandler = createQuestionTextHandler(this);
            
            console.log('[MFC] Modular handlers initialized');
        } catch (e) {
            console.warn('[MFC] Could not initialize modular handlers:', e);
        }
    }

    disconnectedCallback() {
        // Cleanup - remove global dialog handler
        if (window.CSProDialogHandler === this._dialogHandler) {
            delete window.CSProDialogHandler;
        }
        // Remove CAPI message listener
        if (this._capiMessageHandler) {
            window.removeEventListener('message', this._capiMessageHandler);
        }
    }
    
    /**
     * Setup message listener for CAPI iframe actions
     * Handles CSProActionInvoker calls from question text HTML
     */
    _setupCapiMessageListener() {
        this._capiMessageHandler = (event) => {
            if (event.data && event.data.type === 'cspro-action') {
                this._handleCapiAction(event.data);
            }
        };
        window.addEventListener('message', this._capiMessageHandler);
    }
    
    /**
     * Handle action from CAPI iframe (CSProActionInvoker calls)
     */
    async _handleCapiAction(data) {
        console.log('[MFC] CAPI action received:', data.action, data);
        
        switch (data.action) {
            case 'endRoster':
                if (this.engine && typeof this.engine.endGroup === 'function') {
                    await this._handleEndGroup();
                }
                break;
                
            case 'endGroup':
                if (this.engine && typeof this.engine.endGroup === 'function') {
                    await this._handleEndGroup();
                }
                break;
                
            case 'advance':
                await this._advanceWithValue('');
                break;
                
            case 'setResponse':
                if (data.value !== undefined) {
                    await this._advanceWithValue(String(data.value));
                }
                break;
                
            default:
                console.log('[MFC] Unhandled CAPI action:', data.action);
        }
    }
    
    /**
     * Setup the CSProDialogHandler for WASM engine callbacks
     * This provides native CSPro dialog support using html/dialogs templates
     */
    _setupCSProDialogHandler() {
        const self = this;
        
        this._dialogHandler = {
            /**
             * Show a named dialog (errmsg, choice, etc.)
             * @param {string} dialogName - Name of the dialog (e.g., 'errmsg')
             * @param {string} inputDataJson - JSON input data for the dialog
             * @returns {Promise<string|null>} JSON result string
             */
            async showDialogAsync(dialogName, inputDataJson) {
                console.log('[CSProDialogHandler] showDialogAsync:', dialogName);
                try {
                    const inputData = JSON.parse(inputDataJson);
                    return await self._showNativeDialog(dialogName, inputData);
                } catch (e) {
                    console.error('[CSProDialogHandler] showDialogAsync error:', e);
                    return null;
                }
            },
            
            /**
             * Show an HTML dialog from a file path
             * @param {string} dialogPath - Path to the HTML dialog file
             * @param {string} inputDataJson - JSON input data
             * @param {string} optionsJson - Display options JSON
             * @returns {Promise<string|null>} JSON result string
             */
            async showHtmlDialogAsync(dialogPath, inputDataJson, optionsJson) {
                console.log('[CSProDialogHandler] showHtmlDialogAsync:', dialogPath);
                try {
                    const inputData = JSON.parse(inputDataJson);
                    const options = optionsJson ? JSON.parse(optionsJson) : {};
                    return await self._showHtmlDialog(dialogPath, inputData, options);
                } catch (e) {
                    console.error('[CSProDialogHandler] showHtmlDialogAsync error:', e);
                    return null;
                }
            },
            
            /**
             * Show a modal dialog (like Windows MessageBox)
             * @param {string} title - Dialog title
             * @param {string} message - Dialog message
             * @param {number} mbType - MessageBox type (0=OK, 1=OKCANCEL, 4=YESNO)
             * @returns {Promise<number>} Button ID (1=OK/YES, 2=CANCEL/NO, etc.)
             */
            async showModalDialogAsync(title, message, mbType) {
                console.log('[CSProDialogHandler] showModalDialogAsync:', mbType);
                return await self._showModalDialog(title, message, mbType);
            },
            
            /**
             * Get input data for a dialog
             * @param {string} dialogId - Dialog identifier
             * @returns {Promise<string|null>} JSON input data
             */
            async getInputDataAsync(dialogId) {
                console.log('[CSProDialogHandler] getInputDataAsync:', dialogId);
                if (self._dialogInputData) {
                    return JSON.stringify(self._dialogInputData);
                }
                return null;
            }
        };
        
        // Register globally for WASM callbacks
        window.CSProDialogHandler = this._dialogHandler;
    }
    
    _cacheDialogElements() {
        this.$.dialogOverlay = this.shadowRoot.querySelector('#dialogOverlay');
        this.$.dialogContainer = this.shadowRoot.querySelector('#dialogContainer');
    }

    /**
     * Show a native CSPro dialog by name (errmsg, choice, select, etc.)
     * Loads the actual HTML dialog from html/dialogs folder in an iframe
     * Intercepts action-invoker.js to provide web-based implementation
     * @param {string} dialogName - Name of the dialog (e.g., 'errmsg', 'select')
     * @param {object} inputData - Input data for the dialog
     * @returns {Promise<string|null>} JSON result string
     */
    async _showNativeDialog(dialogName, inputData) {
        console.log('[CSEntryMFCView] _showNativeDialog (iframe):', dialogName, inputData);
        
        // Map dialog name to HTML file path
        const dialogPath = `./dialogs/${dialogName}.html`;
        
        return await this._showIframeDialog(dialogPath, inputData);
    }
    
    /**
     * Show a dialog by loading its HTML file in an iframe
     * Fetches HTML content and modifies it to inject web-based action invoker BEFORE loading
     * @param {string} dialogPath - Path to the dialog HTML file
     * @param {object} inputData - Input data for the dialog
     * @returns {Promise<string|null>} JSON result string
     */
    async _showIframeDialog(dialogPath, inputData) {
        return new Promise(async (resolve) => {
            console.log('[CSEntryMFCView] Loading iframe dialog:', dialogPath, inputData);
            
            // Store input data and resolve function for this dialog
            this._currentDialogInputData = inputData;
            this._currentDialogResolve = resolve;
            
            // Fetch the dialog HTML and modify it
            let modifiedHtml;
            try {
                const response = await fetch(dialogPath);
                if (!response.ok) {
                    console.error('[CSEntryMFCView] Failed to fetch dialog:', response.status);
                    resolve(JSON.stringify({ result: { error: 'Failed to load dialog' } }));
                    return;
                }
                const originalHtml = await response.text();
                modifiedHtml = this._modifyDialogHtml(originalHtml, inputData);
            } catch (e) {
                console.error('[CSEntryMFCView] Error fetching dialog:', e);
                resolve(JSON.stringify({ result: { error: e.message } }));
                return;
            }
            
            // Create iframe container with overlay
            const overlay = document.createElement('div');
            overlay.className = 'cspro-dialog-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            // Create iframe - start with a reasonable default size
            const iframe = document.createElement('iframe');
            iframe.className = 'cspro-dialog-iframe';
            iframe.style.cssText = `
                border: none;
                background: white;
                border-radius: 4px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                max-width: 90vw;
                max-height: 85vh;
                min-width: 350px;
                min-height: 300px;
                width: auto;
                height: auto;
            `;
            
            // Store references for cleanup
            this._currentDialogOverlay = overlay;
            this._currentDialogIframe = iframe;
            
            // Listen for messages from the iframe (for CS.UI.closeDialog)
            const messageHandler = (event) => {
                if (event.data && event.data.type === 'cspro-dialog-close') {
                    console.log('[CSEntryMFCView] Dialog close message:', event.data);
                    window.removeEventListener('message', messageHandler);
                    document.removeEventListener('keydown', keyHandler);
                    
                    // Clean up
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                    this._currentDialogOverlay = null;
                    this._currentDialogIframe = null;
                    this._currentDialogInputData = null;
                    this._currentDialogResolve = null;
                    
                    // Return result - the dialog sends {result: {...}}
                    const result = event.data.result;
                    resolve(JSON.stringify(result));
                } else if (event.data && event.data.type === 'cspro-dialog-resize') {
                    // Handle resize request from dialog - ensure good sizing
                    const { width, height } = event.data;
                    const maxW = window.innerWidth * 0.9;
                    const maxH = window.innerHeight * 0.85;
                    if (width) {
                        const newWidth = Math.max(350, Math.min(width + 10, maxW));
                        iframe.style.width = `${newWidth}px`;
                    }
                    if (height) {
                        const newHeight = Math.max(300, Math.min(height + 10, maxH));
                        iframe.style.height = `${newHeight}px`;
                    }
                    console.log('[CSEntryMFCView] Dialog requested resize:', { width, height });
                }
            };
            window.addEventListener('message', messageHandler);
            
            // Handle ESC key to close dialog
            const keyHandler = (e) => {
                if (e.key === 'Escape') {
                    window.removeEventListener('message', messageHandler);
                    document.removeEventListener('keydown', keyHandler);
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                    this._currentDialogOverlay = null;
                    this._currentDialogIframe = null;
                    resolve(JSON.stringify({ result: { cancelled: true } }));
                }
            };
            document.addEventListener('keydown', keyHandler);
            
            // Add onload handler to auto-size the iframe
            iframe.onload = () => {
                // Give the dialog a moment to render its content
                setTimeout(() => {
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        if (iframeDoc) {
                            // Try to get the container dimensions from the dialog
                            const container = iframeDoc.querySelector('#mContainer, .my-dialog, .dialog-container');
                            if (container) {
                                const contentWidth = container.scrollWidth || container.offsetWidth;
                                const contentHeight = container.scrollHeight || container.offsetHeight;
                                
                                // Add some padding
                                const newWidth = Math.min(contentWidth + 20, window.innerWidth * 0.9);
                                const newHeight = Math.min(contentHeight + 20, window.innerHeight * 0.85);
                                
                                if (newWidth > 350) iframe.style.width = `${newWidth}px`;
                                if (newHeight > 300) iframe.style.height = `${newHeight}px`;
                                
                                console.log('[CSEntryMFCView] Auto-sized dialog iframe:', { newWidth, newHeight });
                            }
                        }
                    } catch (e) {
                        console.log('[CSEntryMFCView] Could not auto-size iframe (cross-origin or error):', e);
                    }
                }, 100);
            };
            
            // Load the modified HTML into the iframe using srcdoc
            iframe.srcdoc = modifiedHtml;
            
            overlay.appendChild(iframe);
            document.body.appendChild(overlay);
        });
    }
    
    /**
     * Modify dialog HTML to inject web-based action invoker BEFORE original scripts
     * @param {string} html - Original dialog HTML content
     * @param {object} inputData - Input data for the dialog
     * @returns {string} Modified HTML with injected action invoker
     */
    _modifyDialogHtml(html, inputData) {
        // Create the web action invoker script that must run FIRST
        const webActionInvokerScript = `
<script>
(function() {
    // Input data passed from parent - available immediately
    const __inputData = ${JSON.stringify(inputData)};
    const __displayOptions = {};
    
    console.log('[WebActionInvoker] Initializing with input:', __inputData);
    
    // Web-based CSProActionInvoker - MUST be defined before original action-invoker.js loads
    class CSProActionInvoker {
        constructor(accessToken) {
            this.accessToken = accessToken;
            
            // Initialize UI namespace
            this.UI = {
                alert: function(args) {
                    if (typeof args === 'string') alert(args);
                    else if (args && args.message) alert(args.message);
                    return null;
                },
                alertAsync: function(args) {
                    return new Promise(resolve => {
                        if (typeof args === 'string') alert(args);
                        else if (args && args.message) alert(args.message);
                        resolve(null);
                    });
                },
                closeDialog: function(args) {
                    console.log('[WebActionInvoker] closeDialog:', args);
                    window.parent.postMessage({
                        type: 'cspro-dialog-close',
                        result: args
                    }, '*');
                    return null;
                },
                closeDialogAsync: function(args) {
                    this.closeDialog(args);
                    return Promise.resolve(null);
                },
                getDisplayOptions: function() {
                    return __displayOptions;
                },
                getDisplayOptionsAsync: function() {
                    return Promise.resolve(__displayOptions);
                },
                getInputData: function() {
                    console.log('[WebActionInvoker] getInputData returning:', __inputData);
                    return __inputData;
                },
                getInputDataAsync: function() {
                    return Promise.resolve(__inputData);
                },
                getMaxDisplayDimensions: function() {
                    // Use most of the viewport for dialogs - allow dialogs to grow to fit content
                    return { 
                        width: Math.floor((window.innerWidth || 800) * 0.9), 
                        height: Math.floor((window.innerHeight || 600) * 0.85)
                    };
                },
                getMaxDisplayDimensionsAsync: function() {
                    return Promise.resolve(this.getMaxDisplayDimensions());
                },
                setDisplayOptions: function(args) {
                    Object.assign(__displayOptions, args);
                    // Notify parent of size change
                    if (args.width || args.height) {
                        window.parent.postMessage({
                            type: 'cspro-dialog-resize',
                            width: args.width,
                            height: args.height
                        }, '*');
                    }
                    return null;
                },
                setDisplayOptionsAsync: function(args) {
                    this.setDisplayOptions(args);
                    return Promise.resolve(null);
                },
                postWebMessage: function() { throw new Error('Not supported'); },
                postWebMessageAsync: function() { return Promise.reject(new Error('Not supported')); },
                showDialog: function() { throw new Error('Not supported'); },
                showDialogAsync: function() { return Promise.reject(new Error('Not supported')); },
                view: function() { throw new Error('Not supported'); },
                viewAsync: function() { return Promise.reject(new Error('Not supported')); },
                enumerateWebViews: function() { throw new Error('Not supported'); },
                enumerateWebViewsAsync: function() { return Promise.reject(new Error('Not supported')); }
            };
            
            // Add stub namespaces
            const notSupported = () => { throw new Error('Not supported in web dialog'); };
            const notSupportedAsync = () => Promise.reject(new Error('Not supported in web dialog'));
            
            this.Application = { getFormFile: notSupported, getFormFileAsync: notSupportedAsync, getQuestionnaireContent: notSupported, getQuestionnaireContentAsync: notSupportedAsync, getQuestionText: notSupported, getQuestionTextAsync: notSupportedAsync };
            this.Clipboard = { getText: notSupported, getTextAsync: notSupportedAsync, putText: notSupported, putTextAsync: notSupportedAsync };
            this.Data = { getCase: notSupported, getCaseAsync: notSupportedAsync };
            this.Dictionary = { getDictionary: notSupported, getDictionaryAsync: notSupportedAsync };
            this.File = { copy: notSupported, copyAsync: notSupportedAsync, readBytes: notSupported, readBytesAsync: notSupportedAsync, readLines: notSupported, readLinesAsync: notSupportedAsync, readText: notSupported, readTextAsync: notSupportedAsync, writeBytes: notSupported, writeBytesAsync: notSupportedAsync, writeLines: notSupported, writeLinesAsync: notSupportedAsync, writeText: notSupported, writeTextAsync: notSupportedAsync };
            this.Hash = { createHash: notSupported, createHashAsync: notSupportedAsync, createMd5: notSupported, createMd5Async: notSupportedAsync };
            this.Localhost = { mapActionResult: notSupported, mapActionResultAsync: notSupportedAsync, mapFile: notSupported, mapFileAsync: notSupportedAsync, mapSymbol: notSupported, mapSymbolAsync: notSupportedAsync, mapText: notSupported, mapTextAsync: notSupportedAsync };
            this.Logic = { eval: notSupported, evalAsync: notSupportedAsync, getSymbol: notSupported, getSymbolAsync: notSupportedAsync, getSymbolMetadata: notSupported, getSymbolMetadataAsync: notSupportedAsync, getSymbolValue: notSupported, getSymbolValueAsync: notSupportedAsync, invoke: notSupported, invokeAsync: notSupportedAsync, updateSymbolValue: notSupported, updateSymbolValueAsync: notSupportedAsync };
            this.Message = { formatText: notSupported, formatTextAsync: notSupportedAsync, getText: notSupported, getTextAsync: notSupportedAsync };
            this.Path = { createDirectory: notSupported, createDirectoryAsync: notSupportedAsync, getDirectoryListing: notSupported, getDirectoryListingAsync: notSupportedAsync, getPathInfo: notSupported, getPathInfoAsync: notSupportedAsync, getSpecialPaths: notSupported, getSpecialPathsAsync: notSupportedAsync, selectFile: notSupported, selectFileAsync: notSupportedAsync, showFileDialog: notSupported, showFileDialogAsync: notSupportedAsync };
            this.Settings = { getValue: notSupported, getValueAsync: notSupportedAsync, putValue: notSupported, putValueAsync: notSupportedAsync };
            this.Sqlite = { close: notSupported, closeAsync: notSupportedAsync, exec: notSupported, execAsync: notSupportedAsync, open: notSupported, openAsync: notSupportedAsync, rekey: notSupported, rekeyAsync: notSupportedAsync };
            this.System = { getSharableUri: notSupported, getSharableUriAsync: notSupportedAsync, selectDocument: notSupported, selectDocumentAsync: notSupportedAsync };
        }
        
        getWindowForEventListener() { return window; }
        execute(args) { throw new Error('execute not supported in web mode'); }
        executeAsync(args) { return Promise.reject(new Error('executeAsync not supported in web mode')); }
        registerAccessToken(args) { return null; }
        registerAccessTokenAsync(args) { return Promise.resolve(null); }
    }
    
    // Make CSProActionInvoker available globally BEFORE any other scripts
    window.CSProActionInvoker = CSProActionInvoker;
    
    console.log('[WebActionInvoker] CSProActionInvoker class defined globally');
})();
</script>
`;
        
        // Remove the original action-invoker.js script tag (it's no longer needed)
        // The dialogs will use our CSProActionInvoker class defined above
        let modifiedHtml = html.replace(
            /<script\s+src=["'][^"']*action-invoker\.js["'][^>]*><\/script>/gi,
            '<!-- action-invoker.js replaced by web implementation -->'
        );
        
        // Also handle self-closing script tags
        modifiedHtml = modifiedHtml.replace(
            /<script\s+src=["'][^"']*action-invoker\.js["'][^>]*\/>/gi,
            '<!-- action-invoker.js replaced by web implementation -->'
        );
        
        // Fix resource paths - the dialogs reference /external/*, /css/*, etc. with absolute paths
        // We need to rewrite these to point to our dialogs folder structure
        // The resources are at ./dialogs/external/ and ./dialogs/css/
        const dialogsBaseUrl = new URL('./dialogs/', window.location.href).href;
        
        // Rewrite absolute paths to use the dialogs base URL
        // Use capture groups to preserve the quote style
        // /external/ -> {dialogsBaseUrl}external/
        // /css/ -> {dialogsBaseUrl}css/
        modifiedHtml = modifiedHtml.replace(/href=(["'])\/external\//g, `href=$1${dialogsBaseUrl}external/`);
        modifiedHtml = modifiedHtml.replace(/src=(["'])\/external\//g, `src=$1${dialogsBaseUrl}external/`);
        modifiedHtml = modifiedHtml.replace(/href=(["'])\/css\//g, `href=$1${dialogsBaseUrl}css/`);
        modifiedHtml = modifiedHtml.replace(/src=(["'])\/css\//g, `src=$1${dialogsBaseUrl}css/`);
        
        // Add a base tag and inject our script at the very start of <head>
        if (modifiedHtml.includes('<head>')) {
            modifiedHtml = modifiedHtml.replace(
                '<head>',
                `<head>
    <base href="${dialogsBaseUrl}">
${webActionInvokerScript}`
            );
        } else if (modifiedHtml.includes('<HEAD>')) {
            modifiedHtml = modifiedHtml.replace(
                '<HEAD>',
                `<HEAD>
    <base href="${dialogsBaseUrl}">
${webActionInvokerScript}`
            );
        } else {
            // No head tag, prepend to html
            modifiedHtml = webActionInvokerScript + modifiedHtml;
        }
        
        return modifiedHtml;
    }
    
    /**
     * Inject web-based CSProActionInvoker into the iframe (legacy - kept for compatibility)
     * @param {HTMLIFrameElement} iframe - The dialog iframe
     * @param {object} inputData - Input data for the dialog
     */
    _injectWebActionInvoker(iframe, inputData) {
        // This method is no longer used - we now modify HTML before loading
        console.log('[CSEntryMFCView] _injectWebActionInvoker called but HTML is pre-modified');
    }
    
    /**
     * Show a dialog that was triggered server-side
     * These dialogs were auto-acknowledged by the server but we still show them to the user
     * @param {object} dialogInfo - { dialogName, inputData, timestamp, autoAcknowledged }
     */
    async _showServerDialog(dialogInfo) {
        console.log('[CSEntryMFCView] Showing server dialog:', dialogInfo);
        
        const { dialogName, inputData } = dialogInfo;
        
        // Use the native iframe dialog system to show the dialog
        try {
            await this._showNativeDialog(dialogName, inputData);
        } catch (e) {
            console.error('[CSEntryMFCView] Error showing server dialog:', e);
        }
    }

    /**
     * Show a select dialog for field value selection (like CSEntry MFC)
     * This is triggered when a field has captureType with responses
     * @param {object} field - Field data from engine with responses
     * @returns {Promise<string|null>} Selected value code or null if cancelled
     */
    async _showFieldSelectDialog(field) {
        const responses = field.responses || [];
        if (responses.length === 0) {
            console.log('[MFC] _showFieldSelectDialog: No responses for field', field.name);
            return null;
        }
        
        const CT = CSEntryMFCView.CAPTURE_TYPES;
        const captureType = field.captureType ?? CT.TextBox;
        const isMultiple = captureType === CT.CheckBox;
        const isComboBox = captureType === CT.ComboBox;
        
        // For ComboBox, show a custom editable dialog instead of select.html
        // ComboBox allows the user to type any value OR select from list
        if (isComboBox) {
            return this._showComboBoxDialog(field, responses);
        }
        
        // Build input data for select.html dialog
        // Format matches what select.html expects
        const inputData = {
            title: field.label || field.name,
            multiple: isMultiple,
            header: [
                { caption: 'Code' },
                { caption: 'Label' }
            ],
            rows: responses.map((resp, i) => ({
                index: i,
                textColor: resp.textColor ? `#${resp.textColor.toString(16).padStart(6, '0')}` : '#000000',
                columns: [
                    { text: resp.code || '' },
                    { text: resp.label || '' }
                ]
            }))
        };
        
        console.log('[MFC] _showFieldSelectDialog:', field.name, 'responses:', responses.length, 'multiple:', isMultiple);
        
        try {
            // Show select.html dialog
            const resultJson = await this._showNativeDialog('select', inputData);
            const result = typeof resultJson === 'string' ? JSON.parse(resultJson) : resultJson;
            
            console.log('[MFC] Select dialog result:', result);
            
            // Extract selected value from result
            // select.html returns { result: { rowIndices: [0, 1, ...] } }
            if (result && result.result && result.result.rowIndices && result.result.rowIndices.length > 0) {
                const selectedIndex = result.result.rowIndices[0];
                if (selectedIndex >= 0 && selectedIndex < responses.length) {
                    const selectedCode = responses[selectedIndex].code;
                    console.log('[MFC] Selected value:', selectedCode);
                    return selectedCode;
                }
            }
            
            // Dialog was cancelled or no selection
            console.log('[MFC] Select dialog cancelled or no selection');
            return null;
        } catch (e) {
            console.error('[MFC] Error showing select dialog:', e);
            return null;
        }
    }

    /**
     * Show a ComboBox dialog that allows both text entry AND selection from list
     * This differs from the standard select dialog (DropDown) which only allows selection
     * @param {Object} field - Field object with name, label, etc.
     * @param {Array} responses - Array of {code, label} response options
     * @returns {Promise<string|null>} Entered/selected value or null if cancelled
     */
    async _showComboBoxDialog(field, responses) {
        return new Promise((resolve) => {
            const title = field.label || field.name;
            const maxLength = field.length || field.alphaLength || field.integerPartLength || 20;
            
            // Build rows HTML for the response list
            const rowsHtml = responses.map((resp, i) => 
                `<tr class="combobox-row" data-index="${i}" data-code="${this._escapeHtml(resp.code)}">
                    <td>${this._escapeHtml(resp.code)}</td>
                    <td>${this._escapeHtml(resp.label)}</td>
                </tr>`
            ).join('');
            
            const dialogHtml = `
                <div class="dialog-combobox">
                    <div class="dialog-combobox-header">
                        <span class="dialog-combobox-title">${this._escapeHtml(title)}</span>
                        <button type="button" class="dialog-close-btn" aria-label="Close">&times;</button>
                    </div>
                    <div class="dialog-combobox-input-row">
                        <label>Enter value:</label>
                        <input type="text" class="dialog-combobox-input" maxlength="${maxLength}" 
                               placeholder="Type or select from list below...">
                    </div>
                    <div class="dialog-combobox-list-container">
                        <table class="dialog-combobox-table">
                            <thead>
                                <tr><th>Code</th><th>Label</th></tr>
                            </thead>
                            <tbody>${rowsHtml}</tbody>
                        </table>
                    </div>
                    <div class="dialog-combobox-buttons">
                        <button type="button" class="dialog-btn dialog-btn-ok">OK</button>
                        <button type="button" class="dialog-btn dialog-btn-cancel">Cancel</button>
                    </div>
                </div>
            `;
            
            // Show overlay and set content
            this.$.dialogContainer.innerHTML = dialogHtml;
            this.$.dialogOverlay.style.display = 'block';
            
            const dialog = this.$.dialogContainer.querySelector('.dialog-combobox');
            const input = dialog.querySelector('.dialog-combobox-input');
            const okBtn = dialog.querySelector('.dialog-btn-ok');
            const cancelBtn = dialog.querySelector('.dialog-btn-cancel');
            const closeBtn = dialog.querySelector('.dialog-close-btn');
            const rows = dialog.querySelectorAll('.combobox-row');
            
            let selectedRowIndex = -1;
            
            // Helper to close dialog
            const closeDialog = (value) => {
                this.$.dialogOverlay.style.display = 'none';
                this.$.dialogContainer.innerHTML = '';
                resolve(value);
            };
            
            // Row click - select value and put in input
            rows.forEach((row, idx) => {
                row.addEventListener('click', () => {
                    // Deselect previous
                    rows.forEach(r => r.classList.remove('selected'));
                    // Select this row
                    row.classList.add('selected');
                    selectedRowIndex = idx;
                    // Put code in input
                    input.value = responses[idx].code;
                    input.focus();
                    input.select();
                });
                
                // Double-click to select and confirm
                row.addEventListener('dblclick', () => {
                    input.value = responses[idx].code;
                    closeDialog(input.value);
                });
            });
            
            // OK button - return input value (typed or selected)
            okBtn.addEventListener('click', () => {
                const value = input.value.trim();
                closeDialog(value || null);
            });
            
            // Cancel button
            cancelBtn.addEventListener('click', () => closeDialog(null));
            closeBtn.addEventListener('click', () => closeDialog(null));
            
            // Enter key in input
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const value = input.value.trim();
                    closeDialog(value || null);
                } else if (e.key === 'Escape') {
                    closeDialog(null);
                } else if (e.key === 'ArrowDown' && selectedRowIndex < responses.length - 1) {
                    // Navigate down in list
                    selectedRowIndex++;
                    rows.forEach((r, i) => r.classList.toggle('selected', i === selectedRowIndex));
                    input.value = responses[selectedRowIndex].code;
                    rows[selectedRowIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp' && selectedRowIndex > 0) {
                    // Navigate up in list
                    selectedRowIndex--;
                    rows.forEach((r, i) => r.classList.toggle('selected', i === selectedRowIndex));
                    input.value = responses[selectedRowIndex].code;
                    rows[selectedRowIndex].scrollIntoView({ block: 'nearest' });
                }
            });
            
            // Filter list as user types
            input.addEventListener('input', () => {
                const filterText = input.value.toLowerCase();
                rows.forEach(row => {
                    const code = row.dataset.code.toLowerCase();
                    const label = row.cells[1].textContent.toLowerCase();
                    const matches = code.includes(filterText) || label.includes(filterText);
                    row.style.display = matches ? '' : 'none';
                });
            });
            
            // Focus input on open
            setTimeout(() => input.focus(), 50);
            
            console.log('[MFC] _showComboBoxDialog: opened for', field.name, 'with', responses.length, 'options');
        });
    }

    /**
     * Show a simple message dialog (for errmsg)
     * This recreates the errmsg.html functionality inline
     * @param {object} inputData - { message, title, buttons: [{caption, index}], defaultButtonIndex }
     * @returns {Promise<string>} JSON result string
     */
    async _showSimpleMessageDialog(inputData) {
        return new Promise((resolve) => {
            const { message, title, buttons, defaultButtonIndex } = inputData;
            
            // Build dialog HTML
            // Note: defaultButtonIndex from CSPro is 1-based
            let buttonsHtml = '';
            if (buttons && buttons.length > 0) {
                buttonsHtml = buttons.map((btn, i) => 
                    `<button type="button" class="${(i + 1) === defaultButtonIndex ? 'default-button' : ''}" 
                             data-index="${btn.index}">${this._escapeHtml(btn.caption)}</button>`
                ).join('');
            } else {
                // Default OK button (index 1 as per CSPro convention)
                buttonsHtml = '<button type="button" class="default-button" data-index="1">OK</button>';
            }
            
            const dialogHtml = `
                <div class="dialog-message">
                    ${title ? `<div class="dialog-message-title">${this._escapeHtml(title)}</div>` : ''}
                    <div class="dialog-message-text">${this._escapeHtml(message || '')}</div>
                    <div class="dialog-message-buttons">${buttonsHtml}</div>
                </div>
            `;
            
            // Show overlay and set content
            this.$.dialogContainer.innerHTML = dialogHtml;
            this.$.dialogOverlay.style.display = 'block';
            
            // Store cleanup function
            let cleanup = () => {};
            
            // Helper to close with result
            // CSPro expects {index: N} directly in JSON result (1-based index)
            const closeWithResult = (index) => {
                cleanup();
                this._closeDialog();
                resolve(JSON.stringify({ index }));
            };
            
            // Handle button clicks
            const handleClick = (e) => {
                const btn = e.target.closest('button');
                if (btn) {
                    const index = parseInt(btn.dataset.index, 10);
                    closeWithResult(index);
                }
            };
            
            // Handle keyboard - ESC to close, Enter for default
            const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                    // Return first button index on ESC
                    const firstIndex = buttons?.[0]?.index || 1;
                    closeWithResult(firstIndex);
                } else if (e.key === 'Enter') {
                    const focusedBtn = this.$.dialogContainer.querySelector('button:focus');
                    if (focusedBtn) {
                        const index = parseInt(focusedBtn.dataset.index, 10);
                        closeWithResult(index);
                    } else {
                        // Click default button
                        const defaultBtn = this.$.dialogContainer.querySelector('.default-button');
                        if (defaultBtn) {
                            const index = parseInt(defaultBtn.dataset.index, 10);
                            closeWithResult(index);
                        }
                    }
                }
            };
            
            // Attach listeners
            this.$.dialogContainer.addEventListener('click', handleClick);
            document.addEventListener('keydown', handleKeydown);
            
            // Cleanup function to remove listeners
            cleanup = () => {
                this.$.dialogContainer.removeEventListener('click', handleClick);
                document.removeEventListener('keydown', handleKeydown);
            };
            
            // Focus default button
            const defaultBtn = this.$.dialogContainer.querySelector('.default-button');
            if (defaultBtn) {
                defaultBtn.focus();
            } else {
                // Focus first button
                const firstBtn = this.$.dialogContainer.querySelector('button');
                if (firstBtn) firstBtn.focus();
            }
        });
    }

    /**
     * Show a choice dialog
     * @param {object} inputData - { title, choices: [{text, value}], selectedValue }
     * @returns {Promise<string>} JSON result string
     */
    async _showChoiceDialog(inputData) {
        return new Promise((resolve) => {
            const { title, choices, selectedValue } = inputData;
            
            let choicesHtml = '';
            if (choices && choices.length > 0) {
                choicesHtml = choices.map((choice, i) => 
                    `<div class="choice-item ${choice.value === selectedValue ? 'selected' : ''}" 
                          data-value="${choice.value}" data-index="${i}">
                        ${this._escapeHtml(choice.text)}
                    </div>`
                ).join('');
            }
            
            const dialogHtml = `
                <div class="dialog-message">
                    ${title ? `<div class="dialog-message-title">${this._escapeHtml(title)}</div>` : ''}
                    <div class="choice-list">${choicesHtml}</div>
                    <div class="dialog-message-buttons">
                        <button type="button" data-action="cancel">Cancel</button>
                        <button type="button" class="default-button" data-action="ok">OK</button>
                    </div>
                </div>
            `;
            
            this.$.dialogContainer.innerHTML = dialogHtml;
            this.$.dialogOverlay.style.display = 'block';
            
            let selectedIndex = choices?.findIndex(c => c.value === selectedValue) ?? -1;
            
            // Handle item selection
            const choiceList = this.$.dialogContainer.querySelector('.choice-list');
            choiceList?.addEventListener('click', (e) => {
                const item = e.target.closest('.choice-item');
                if (item) {
                    choiceList.querySelectorAll('.choice-item').forEach(i => i.classList.remove('selected'));
                    item.classList.add('selected');
                    selectedIndex = parseInt(item.dataset.index, 10);
                }
            });
            
            // Handle double-click to select and close
            choiceList?.addEventListener('dblclick', (e) => {
                const item = e.target.closest('.choice-item');
                if (item) {
                    selectedIndex = parseInt(item.dataset.index, 10);
                    this._closeDialog();
                    const choice = choices[selectedIndex];
                    resolve(JSON.stringify({ result: { value: choice?.value, index: selectedIndex } }));
                }
            });
            
            // Handle button clicks
            this.$.dialogContainer.addEventListener('click', (e) => {
                const btn = e.target.closest('button');
                if (btn) {
                    const action = btn.dataset.action;
                    this._closeDialog();
                    if (action === 'ok' && selectedIndex >= 0) {
                        const choice = choices[selectedIndex];
                        resolve(JSON.stringify({ result: { value: choice?.value, index: selectedIndex } }));
                    } else {
                        resolve(JSON.stringify({ result: { cancelled: true } }));
                    }
                }
            });
        });
    }

    /**
     * Show an HTML dialog from a path
     * Uses iframe-based loading with web action invoker injection
     * @param {string} dialogPath - Path to the HTML file
     * @param {object} inputData - Input data for the dialog
     * @param {object} options - Display options
     * @returns {Promise<string|null>} JSON result string
     */
    async _showHtmlDialog(dialogPath, inputData, options) {
        console.log('[CSEntryMFCView] _showHtmlDialog (iframe):', dialogPath, inputData);
        return await this._showIframeDialog(dialogPath, inputData);
    }

    /**
     * Show a modal dialog (MessageBox style)
     * @param {string} title - Dialog title
     * @param {string} message - Dialog message
     * @param {number} mbType - MessageBox type
     * @returns {Promise<number>} Button ID
     */
    async _showModalDialog(title, message, mbType) {
        // Map MessageBox types to button configurations
        // MB_OK = 0, MB_OKCANCEL = 1, MB_ABORTRETRYIGNORE = 2, MB_YESNOCANCEL = 3, MB_YESNO = 4, MB_RETRYCANCEL = 5
        let buttons;
        let defaultButtonIndex = 0;
        
        switch (mbType & 0x0F) {
            case 0: // MB_OK
                buttons = [{ caption: 'OK', index: 1 }];
                break;
            case 1: // MB_OKCANCEL
                buttons = [{ caption: 'OK', index: 1 }, { caption: 'Cancel', index: 2 }];
                break;
            case 2: // MB_ABORTRETRYIGNORE
                buttons = [{ caption: 'Abort', index: 3 }, { caption: 'Retry', index: 4 }, { caption: 'Ignore', index: 5 }];
                break;
            case 3: // MB_YESNOCANCEL
                buttons = [{ caption: 'Yes', index: 6 }, { caption: 'No', index: 7 }, { caption: 'Cancel', index: 2 }];
                break;
            case 4: // MB_YESNO
                buttons = [{ caption: 'Yes', index: 6 }, { caption: 'No', index: 7 }];
                break;
            case 5: // MB_RETRYCANCEL
                buttons = [{ caption: 'Retry', index: 4 }, { caption: 'Cancel', index: 2 }];
                break;
            default:
                buttons = [{ caption: 'OK', index: 1 }];
        }
        
        const resultJson = await this._showSimpleMessageDialog({ 
            title, 
            message, 
            buttons, 
            defaultButtonIndex 
        });
        
        try {
            const result = JSON.parse(resultJson);
            // _showSimpleMessageDialog returns {index: N} directly, not {result: {index: N}}
            return result.index ?? 1;
        } catch (e) {
            return 1; // Default to OK
        }
    }

    /**
     * Close the dialog overlay
     */
    _closeDialog() {
        if (this.$.dialogOverlay) {
            this.$.dialogOverlay.style.display = 'none';
            this.$.dialogContainer.innerHTML = '';
        }
    }

    /**
     * Show a value set selection dialog (like MFC CSEntry popup)
     * Uses the dialog overlay to display a list of responses for the user to select
     * @param {object} field - The field data containing name, label, etc.
     * @param {array} responses - Array of {code, label, textColor} objects
     */
    _showValueSetDialog(field, responses) {
        console.log('[MFC] Showing value set dialog for field:', field.name, 'with', responses.length, 'responses');
        
        // Store current field info for the dialog
        this._valueSetField = field;
        this._valueSetResponses = responses;
        
        // Build dialog HTML similar to select.html structure
        const title = field.label || field.name || 'Select Value';
        
        let rowsHtml = responses.map((resp, idx) => {
            // Convert textColor int to CSS color if set
            let colorStyle = '';
            if (resp.textColor && resp.textColor !== 0) {
                const r = (resp.textColor >> 16) & 0xFF;
                const g = (resp.textColor >> 8) & 0xFF;
                const b = resp.textColor & 0xFF;
                colorStyle = `color: rgb(${r},${g},${b});`;
            }
            return `
                <tr class="valueset-row" data-index="${idx}" data-code="${this._escapeHtml(String(resp.code))}" tabindex="0" style="${colorStyle}">
                    <td class="valueset-code">${this._escapeHtml(String(resp.code))}</td>
                    <td class="valueset-label">${this._escapeHtml(resp.label || '')}</td>
                </tr>
            `;
        }).join('');
        
        const dialogHtml = `
            <div class="valueset-dialog">
                <div class="valueset-dialog-header">
                    <div class="valueset-dialog-title">${this._escapeHtml(title)}</div>
                    <button type="button" class="valueset-dialog-close" aria-label="Close">&times;</button>
                </div>
                <div class="valueset-dialog-body">
                    <table class="valueset-table">
                        <thead>
                            <tr>
                                <th>Code</th>
                                <th>Label</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rowsHtml}
                        </tbody>
                    </table>
                </div>
                <div class="valueset-dialog-footer">
                    <button type="button" class="valueset-btn valueset-btn-ok">OK</button>
                    <button type="button" class="valueset-btn valueset-btn-cancel">Cancel</button>
                </div>
            </div>
        `;
        
        // Show overlay and set content
        this.$.dialogContainer.innerHTML = dialogHtml;
        this.$.dialogOverlay.style.display = 'block';
        
        // Track selected row
        let selectedRow = null;
        
        // Handle row selection
        const rows = this.$.dialogContainer.querySelectorAll('.valueset-row');
        rows.forEach(row => {
            row.addEventListener('click', () => {
                // Deselect previous
                if (selectedRow) selectedRow.classList.remove('selected');
                // Select this row
                row.classList.add('selected');
                selectedRow = row;
            });
            
            // Double-click selects and confirms
            row.addEventListener('dblclick', () => {
                row.classList.add('selected');
                selectedRow = row;
                this._confirmValueSetSelection(field.name, row.dataset.code);
            });
            
            // Keyboard navigation
            row.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    if (selectedRow) selectedRow.classList.remove('selected');
                    row.classList.add('selected');
                    selectedRow = row;
                    this._confirmValueSetSelection(field.name, row.dataset.code);
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const next = row.nextElementSibling || rows[0];
                    next.focus();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const prev = row.previousElementSibling || rows[rows.length - 1];
                    prev.focus();
                } else if (e.key === 'Escape') {
                    this._closeDialog();
                }
            });
        });
        
        // Handle OK button
        const okBtn = this.$.dialogContainer.querySelector('.valueset-btn-ok');
        okBtn?.addEventListener('click', () => {
            if (selectedRow) {
                this._confirmValueSetSelection(field.name, selectedRow.dataset.code);
            }
        });
        
        // Handle Cancel/Close
        const cancelBtn = this.$.dialogContainer.querySelector('.valueset-btn-cancel');
        const closeBtn = this.$.dialogContainer.querySelector('.valueset-dialog-close');
        cancelBtn?.addEventListener('click', () => this._closeDialog());
        closeBtn?.addEventListener('click', () => this._closeDialog());
        
        // Focus first row
        if (rows.length > 0) {
            rows[0].focus();
        }
    }

    /**
     * Confirm value set selection and advance to next field
     * @param {string} fieldName - Name of the field
     * @param {string} code - Selected value code
     */
    async _confirmValueSetSelection(fieldName, code) {
        console.log('[MFC] Confirming value set selection:', fieldName, '=', code);
        this._closeDialog();
        
        // Use the existing _selectCAPIResponse method which handles field update and engine advance
        await this._selectCAPIResponse(fieldName, code);
    }

    /**
     * Escape HTML for safe display
     */
    _escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue) return;
        
        switch (name) {
            case 'pff-url':
                if (newValue) this.loadApplication(newValue);
                break;
            case 'operator-id':
                this.operatorId = newValue || 'OPERATOR';
                break;
            case 'theme':
                this._applyTheme(newValue);
                break;
        }
    }

    _render() {
        this.shadowRoot.innerHTML = `
            <style>${this._getStyles()}</style>
            <div class="mfc-app">
                <!-- Menu Bar -->
                <div class="mfc-menubar">
                    <div class="menu-item" data-menu="file">File
                        <div class="menu-dropdown" id="menuFile">
                            <div class="menu-dropdown-item" data-action="open-dialog">Open Application...</div>
                            <div class="menu-dropdown-sep"></div>
                            <div class="menu-dropdown-item" data-action="open-server">From Server</div>
                            <div class="menu-dropdown-item" data-action="open-assets">From Assets</div>
                            <div class="menu-dropdown-item" data-action="open-csweb">From CSWeb</div>
                            <div class="menu-dropdown-item" data-action="upload-folder">Upload Folder...</div>
                            <div class="menu-dropdown-sep"></div>
                            <div class="menu-dropdown-item" data-action="new">New Case</div>
                            <div class="menu-dropdown-item" data-action="save">Save Case</div>
                            <div class="menu-dropdown-item" data-action="partial-save">Partial Save</div>
                            <div class="menu-dropdown-sep"></div>
                            <div class="menu-dropdown-item" data-action="close">Close Application</div>
                        </div>
                    </div>
                    <div class="menu-item" data-menu="edit">Edit</div>
                    <div class="menu-item" data-menu="mode">Mode</div>
                    <div class="menu-item" data-menu="view">View</div>
                    <div class="menu-item" data-menu="options">Options
                        <div class="menu-dropdown" id="menuOptions">
                            <div class="menu-dropdown-item menu-label">Value Set Display (Non-Roster):</div>
                            <div class="menu-dropdown-item" data-action="capture-inline">
                                <span class="menu-check" id="checkCaptureInline"></span> Inline Display
                            </div>
                            <div class="menu-dropdown-item" data-action="capture-dialog">
                                <span class="menu-check" id="checkCaptureDialog"></span> Select Dialog
                            </div>
                        </div>
                    </div>
                    <div class="menu-item" data-menu="help">Help</div>
                </div>
                
                <!-- Toolbar -->
                <div class="mfc-toolbar">
                    <button class="toolbar-btn" data-action="new" title="New Case (Ctrl+N)"></button>
                    <button class="toolbar-btn" data-action="open" title="Open Application"></button>
                    <button class="toolbar-btn" data-action="save" title="Save Case (Ctrl+S)"></button>
                    <button class="toolbar-btn" data-action="partial-save" title="Partial Save"></button>
                    <span class="toolbar-sep"></span>
                    <button class="toolbar-btn" data-action="add" title="Add Case"></button>
                    <button class="toolbar-btn" data-action="modify" title="Modify Case"></button>
                    <button class="toolbar-btn" data-action="delete" title="Delete Case"></button>
                    <span class="toolbar-sep"></span>
                    <button class="toolbar-btn" data-action="prev" title="Previous Field"></button>
                    <button class="toolbar-btn" data-action="next" title="Next Field"></button>
                    <button class="toolbar-btn" data-action="endgrp" title="End Group"></button>
                    <span class="toolbar-sep"></span>
                    <button class="toolbar-btn" data-action="find" title="Find Case"></button>
                    <button class="toolbar-btn" data-action="goto" title="Go To Field"></button>
                    <button class="toolbar-btn" data-action="note" title="Field Note"></button>
                </div>
                
                <!-- Main Content -->
                <div class="mfc-main">
                    <!-- Case Tree Panel -->
                    <div class="mfc-tree-panel" id="treePanel">
                        <div class="panel-header">Case Tree</div>
                        <div class="tree-content" id="treeContent"></div>
                    </div>
                    
                    <!-- Splitter -->
                    <div class="mfc-splitter" id="splitter"></div>
                    
                    <!-- Form View Panel -->
                    <div class="mfc-form-panel">
                        <!-- Form Header -->
                        <div class="form-header">
                            <span id="formTitle">No Application Loaded</span>
                            <span id="formInfo"></span>
                        </div>
                        
                        <!-- Form Tabs -->
                        <div class="form-tabs" id="formTabs"></div>
                        
                        <!-- CAPI Panel - At TOP like Windows MFC -->
                        <div class="capi-panel" id="capiPanel"></div>
                        
                        <!-- Form Canvas -->
                        <div class="form-canvas" id="formCanvas">
                            <div class="form-container" id="formContainer">
                                <div class="welcome-message" id="welcomeMessage">
                                    <h2> CSEntry Web</h2>
                                    <p>Load a CSPro application to begin data entry.</p>
                                    <button class="btn btn-primary" id="btnLoadApp">Load Application</button>
                                    
                                    <div class="app-sources">
                                        <h3>Load From:</h3>
                                        <div class="source-grid">
                                            <button class="source-btn" data-source="server">
                                                <span class="source-icon"></span>
                                                <span class="source-label">Server</span>
                                                <span class="source-desc">Applications on the server</span>
                                            </button>
                                            <button class="source-btn" data-source="assets">
                                                <span class="source-icon"></span>
                                                <span class="source-label">Assets</span>
                                                <span class="source-desc">Built-in applications</span>
                                            </button>
                                            <button class="source-btn" data-source="csweb">
                                                <span class="source-icon"></span>
                                                <span class="source-label">CSWeb</span>
                                                <span class="source-desc">CSWeb server sync</span>
                                            </button>
                                            <button class="source-btn" data-source="upload">
                                                <span class="source-icon"></span>
                                                <span class="source-label">Upload</span>
                                                <span class="source-desc">Upload from your computer</span>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Status Bar -->
                <div class="mfc-statusbar">
                    <span class="status-section" id="statusField">Ready</span>
                    <span class="status-section" id="statusOcc"></span>
                    <span class="status-section" id="statusMode">Add Mode</span>
                    <span class="status-section status-progress" id="statusProgress"></span>
                </div>
                
                <!-- CSPro Native Dialog Overlay -->
                <div id="dialogOverlay" class="dialog-overlay" style="display: none;">
                    <div class="dialog-backdrop"></div>
                    <div id="dialogContainer" class="dialog-container">
                        <!-- Dialog content rendered here -->
                    </div>
                </div>
                
                <!-- Application Loading Dialog -->
                <div id="appLoaderOverlay" class="dialog-overlay" style="display: none;">
                    <div class="dialog-backdrop"></div>
                    <div class="app-loader-dialog">
                        <div class="app-loader-header">
                            <span id="appLoaderTitle">Load Application</span>
                            <button class="dialog-close-btn" id="appLoaderClose"></button>
                        </div>
                        <div class="app-loader-tabs">
                            <button class="app-loader-tab active" data-tab="server">Server</button>
                            <button class="app-loader-tab" data-tab="assets">Assets</button>
                            <button class="app-loader-tab" data-tab="csweb">CSWeb</button>
                            <button class="app-loader-tab" data-tab="upload">Upload</button>
                        </div>
                        <div class="app-loader-content">
                            <!-- Server Tab -->
                            <div class="app-loader-panel active" id="panelServer">
                                <div class="app-list" id="serverAppList">
                                    <div class="loading-indicator">Loading applications...</div>
                                </div>
                            </div>
                            <!-- Assets Tab -->
                            <div class="app-loader-panel" id="panelAssets">
                                <div class="app-list" id="assetsAppList">
                                    <div class="loading-indicator">Loading assets...</div>
                                </div>
                            </div>
                            <!-- CSWeb Tab -->
                            <div class="app-loader-panel" id="panelCsweb">
                                <div class="csweb-config">
                                    <label>CSWeb Server URL:</label>
                                    <input type="url" id="cswebUrl" placeholder="https://your-csweb-server.com" />
                                    <button class="btn btn-secondary" id="cswebConnect">Connect</button>
                                </div>
                                <div class="app-list" id="cswebAppList">
                                    <div class="empty-state">Enter CSWeb server URL above</div>
                                </div>
                            </div>
                            <!-- Upload Tab -->
                            <div class="app-loader-panel" id="panelUpload">
                                <div class="upload-zone" id="uploadZone">
                                    <input type="file" id="folderInput" webkitdirectory directory multiple hidden />
                                    <input type="file" id="fileInput" accept=".pff,.pen,.dcf,.fmf,.ent,.qsf" multiple hidden />
                                    <div class="upload-icon"></div>
                                    <div class="upload-text">Drop a folder here or click to browse</div>
                                    <div class="upload-hint">Upload a folder containing your CSPro application files (.pff, .pen, .dcf, .fmf, .ent, .qsf)</div>
                                    <div class="upload-buttons">
                                        <button class="btn btn-secondary" id="btnSelectFolder">Select Folder</button>
                                        <button class="btn btn-secondary" id="btnSelectFiles">Select Files</button>
                                    </div>
                                </div>
                                <div class="upload-preview" id="uploadPreview" style="display: none;">
                                    <div class="upload-preview-header">
                                        <span id="uploadAppName">Application Files</span>
                                        <button class="btn btn-small" id="btnClearUpload">Clear</button>
                                    </div>
                                    <div class="upload-file-list" id="uploadFileList"></div>
                                    <button class="btn btn-primary" id="btnUploadApp">Save & Load Application</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Cache element references
        this._cacheElements();
    }

    _getStyles() {
        return `
            :host {
                display: block;
                width: 100%;
                height: 100%;
                /* CSEntry MFC exact colors from FieldColors.cpp */
                --mfc-window-bg: #f0f0f0;
                --mfc-form-bg: #c0c0c0;
                --mfc-field-bg: #ffffff;           /* Unvisited: white */
                --mfc-field-current: #ffffff;      /* Current: white (same as unvisited) */
                --mfc-field-visited: #00ff00;      /* Visited: green RGB(0,255,0) */
                --mfc-field-skipped: #808080;      /* Skipped (path on): gray RGB(128,128,128) */
                --mfc-field-skipped-pathoff: #ffff00; /* Skipped (path off): yellow */
                --mfc-field-protected: #c0c0c0;    /* Protected: button face gray */
                --mfc-border: #808080;
                --mfc-btn-face: #d4d0c8;
                --mfc-text: #000000;
                --mfc-selection: #0078d7;
                --mfc-selection-text: #ffffff;
            }

            * { box-sizing: border-box; }

            .mfc-app {
                display: flex;
                flex-direction: column;
                height: 100%;
                font-family: 'Segoe UI', Tahoma, sans-serif;
                font-size: 13px;
                color: var(--mfc-text);
                background: var(--mfc-window-bg);
            }

            /* Menu Bar */
            .mfc-menubar {
                display: flex;
                height: 24px;
                background: var(--mfc-window-bg);
                border-bottom: 1px solid var(--mfc-border);
                padding: 0 4px;
            }

            .menu-item {
                padding: 2px 10px;
                cursor: pointer;
                user-select: none;
            }

            .menu-item:hover {
                background: var(--mfc-selection);
                color: var(--mfc-selection-text);
            }

            /* Toolbar */
            .mfc-toolbar {
                display: flex;
                height: 32px;
                background: linear-gradient(180deg, #f5f5f5 0%, #e0e0e0 100%);
                border-bottom: 1px solid var(--mfc-border);
                padding: 2px 4px;
                gap: 2px;
                align-items: center;
            }

            .toolbar-btn {
                width: 26px;
                height: 26px;
                display: flex;
                align-items: center;
                justify-content: center;
                border: 1px solid transparent;
                background: transparent;
                cursor: pointer;
                border-radius: 2px;
                font-size: 14px;
            }

            .toolbar-btn:hover {
                border-color: var(--mfc-border);
                background: white;
            }

            .toolbar-btn:active {
                background: var(--mfc-btn-face);
            }

            .toolbar-sep {
                width: 1px;
                height: 22px;
                background: var(--mfc-border);
                margin: 0 4px;
            }

            /* Main Content */
            .mfc-main {
                display: flex;
                flex: 1;
                overflow: hidden;
            }

            /* Tree Panel */
            .mfc-tree-panel {
                width: 250px;
                min-width: 150px;
                max-width: 400px;
                background: white;
                border-right: 1px solid var(--mfc-border);
                display: flex;
                flex-direction: column;
            }

            .panel-header {
                padding: 6px 8px;
                background: linear-gradient(180deg, #f5f5f5 0%, #e0e0e0 100%);
                border-bottom: 1px solid var(--mfc-border);
                font-weight: 600;
                font-size: 11px;
            }

            .tree-content {
                flex: 1;
                overflow: auto;
                padding: 4px 0;
            }

            /* Tree Node Styles */
            .tree-node {
                user-select: none;
            }

            .tree-node-header {
                display: flex;
                align-items: center;
                padding: 2px 4px;
                cursor: pointer;
                min-height: 22px;
            }

            .tree-node-header:hover {
                background: #e5f3ff;
            }

            .tree-node-header.selected {
                background: var(--mfc-selection);
                color: var(--mfc-selection-text);
            }

            .tree-toggle {
                width: 16px;
                height: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
            }

            .tree-toggle::before { content: ''; }
            .tree-node.expanded > .tree-node-header .tree-toggle::before {
                transform: rotate(90deg);
            }
            .tree-toggle.empty::before { content: ''; }

            .tree-icon {
                width: 16px;
                height: 16px;
                margin-right: 4px;
                font-size: 12px;
            }

            .tree-label {
                flex: 1;
                font-size: 11px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .tree-value {
                margin-left: 8px;
                font-family: 'Consolas', monospace;
                font-size: 11px;
                color: #666;
            }

            .tree-children {
                padding-left: 16px;
                display: none;
            }

            .tree-node.expanded > .tree-children {
                display: block;
            }

            /* Splitter */
            .mfc-splitter {
                width: 5px;
                background: var(--mfc-btn-face);
                cursor: col-resize;
            }

            .mfc-splitter:hover {
                background: var(--mfc-selection);
            }

            /* Form Panel */
            .mfc-form-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: var(--mfc-form-bg);
            }

            .form-header {
                padding: 4px 8px;
                background: linear-gradient(180deg, #f5f5f5 0%, #e0e0e0 100%);
                border-bottom: 1px solid var(--mfc-border);
                font-weight: 600;
                font-size: 11px;
                display: flex;
                justify-content: space-between;
            }

            .form-tabs {
                display: flex;
                gap: 2px;
                padding: 0 4px;
                background: var(--mfc-btn-face);
                border-bottom: 1px solid var(--mfc-border);
            }

            .form-tab {
                padding: 4px 12px;
                background: var(--mfc-btn-face);
                border: 1px solid var(--mfc-border);
                border-bottom: none;
                margin-bottom: -1px;
                cursor: pointer;
                font-size: 11px;
            }

            .form-tab.active {
                background: var(--mfc-form-bg);
                border-bottom: 1px solid var(--mfc-form-bg);
            }

            /* Form Canvas */
            .form-canvas {
                flex: 1;
                overflow: auto;
                position: relative;
            }

            .form-container {
                position: relative;
                min-width: 800px;
                min-height: 600px;
                background: var(--mfc-form-bg);
            }

            .welcome-message {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                color: #666;
            }

            .welcome-message h2 {
                margin: 0 0 12px;
            }

            .welcome-message p {
                margin: 0 0 20px;
            }

            /* Form Elements */
            .form-text {
                position: absolute;
                font-family: 'MS Sans Serif', 'Segoe UI', Tahoma, sans-serif;
                font-size: 13px;
                white-space: nowrap;
                color: #000000;
            }

            .form-text.bold { font-weight: bold; }
            .form-text.underline { text-decoration: underline; }

            .form-box {
                position: absolute;
                border: 1px solid var(--mfc-border);
                background: transparent;
                pointer-events: none;
            }

            .form-field-label {
                position: absolute;
                font-size: 11px;
            }

            .form-field-input {
                position: absolute;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 14px;
                border: 2px inset #808080;
                padding: 2px 4px;
                outline: none;
                background: var(--mfc-field-bg);
                letter-spacing: 2px;
            }

            .form-field-input:focus {
                background: var(--mfc-field-current);
                border-color: #000080;
                box-shadow: inset 0 0 0 1px #000080;
            }

            .form-field-input.visited { background: var(--mfc-field-visited); }
            .form-field-input.skipped { background: var(--mfc-field-skipped); }
            .form-field-input.protected { 
                background: var(--mfc-field-protected); 
                cursor: not-allowed;
                color: #404040;
            }
            .form-field-input.numeric { text-align: right; }
            .form-field-input.uppercase { text-transform: uppercase; }

            /* Tickmark container for numeric fields - MFC-style character position markers */
            .form-field-tickmark-container {
                position: absolute;
                display: flex;
                align-items: flex-end;
                pointer-events: none;
            }
            
            .form-field-tickmark-input {
                position: relative;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 14px;
                border: 2px inset #808080;
                padding: 2px 4px;
                outline: none;
                background: var(--mfc-field-bg);
                letter-spacing: 0;
                z-index: 1;
            }
            
            .form-field-tickmark-input:focus {
                background: var(--mfc-field-current);
                border-color: #000080;
                box-shadow: inset 0 0 0 1px #000080;
            }
            
            .form-field-tickmarks {
                position: absolute;
                bottom: 2px;
                left: 4px;
                right: 4px;
                height: 6px;
                display: flex;
                pointer-events: none;
            }
            
            .tickmark-char {
                flex: 1;
                border-right: 1px solid #808080;
                height: 100%;
            }
            
            .tickmark-char:last-child {
                border-right: none;
            }
            
            .tickmark-decimal {
                border-right: 1px solid #000080;
                border-right-width: 2px;
            }
            
            /* Capture Type: Radio Button Group */
            .form-field-radio-group {
                position: absolute;
                display: flex;
                flex-direction: column;
                gap: 4px;
                padding: 4px;
                background: var(--mfc-window-bg);
                border: 1px solid var(--mfc-border);
            }
            
            .form-field-radio-option {
                display: flex;
                align-items: center;
                gap: 6px;
                cursor: pointer;
                padding: 2px 4px;
            }
            
            .form-field-radio-option:hover {
                background: var(--mfc-field-current);
            }
            
            .form-field-radio-option input[type="radio"] {
                margin: 0;
                cursor: pointer;
            }
            
            .form-field-radio-option .option-code {
                font-family: 'Consolas', monospace;
                font-size: 12px;
                color: #666;
                min-width: 30px;
            }
            
            .form-field-radio-option .option-label {
                font-size: 12px;
            }
            
            /* Capture Type: Checkbox Group */
            .form-field-checkbox-group {
                position: absolute;
                display: flex;
                flex-direction: column;
                gap: 4px;
                padding: 4px;
                background: var(--mfc-window-bg);
                border: 1px solid var(--mfc-border);
            }
            
            .form-field-checkbox-option {
                display: flex;
                align-items: center;
                gap: 6px;
                cursor: pointer;
                padding: 2px 4px;
            }
            
            .form-field-checkbox-option:hover {
                background: var(--mfc-field-current);
            }
            
            .form-field-checkbox-option input[type="checkbox"] {
                margin: 0;
                cursor: pointer;
            }
            
            .form-field-checkbox-option .option-code {
                font-family: 'Consolas', monospace;
                font-size: 12px;
                color: #666;
                min-width: 30px;
            }
            
            .form-field-checkbox-option .option-label {
                font-size: 12px;
            }
            
            /* Capture Type: DropDown / ComboBox */
            .form-field-dropdown {
                position: absolute;
                font-family: 'Segoe UI', Tahoma, sans-serif;
                font-size: 12px;
                border: 2px inset #808080;
                padding: 2px;
                background: var(--mfc-field-bg);
                cursor: pointer;
            }
            
            .form-field-dropdown:focus {
                background: var(--mfc-field-current);
                border-color: #000080;
            }
            
            /* Capture Type: ComboBox (editable dropdown) */
            .form-field-combobox {
                position: absolute;
                display: inline-block;
            }
            
            .form-field-combobox-input {
                font-family: 'Segoe UI', Tahoma, sans-serif;
                font-size: 12px;
                border: 2px inset #808080;
                padding: 2px 4px;
                background: var(--mfc-field-bg);
                width: 100%;
                box-sizing: border-box;
            }
            
            .form-field-combobox-input:focus {
                background: var(--mfc-field-current);
                border-color: #000080;
            }
            
            .form-field-combobox-input.numeric {
                text-align: right;
                font-family: 'Consolas', monospace;
            }
            
            /* Roster ComboBox styles */
            .roster-field-container.capture-combobox {
                display: block;
                width: 100%;
            }
            
            .roster-combobox-input {
                width: 100%;
                height: 20px;
                font-size: 11px;
                font-family: inherit;
                border: 1px solid #ccc;
                background: white;
                padding: 0 2px;
                box-sizing: border-box;
            }
            
            .roster-combobox-input:focus {
                border-color: #0078d4;
                outline: none;
            }
            
            /* Capture Type: Slider */
            .form-field-slider-container {
                position: absolute;
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 4px;
            }
            
            .form-field-slider {
                flex: 1;
                cursor: pointer;
            }
            
            .form-field-slider-value {
                font-family: 'Consolas', monospace;
                font-size: 12px;
                min-width: 40px;
                text-align: right;
            }
            
            /* Capture Type: Date */
            .form-field-date {
                position: absolute;
                font-family: 'Consolas', monospace;
                font-size: 14px;
                border: 2px inset #808080;
                padding: 2px 4px;
                background: var(--mfc-field-bg);
            }
            
            .form-field-date:focus {
                background: var(--mfc-field-current);
                border-color: #000080;
            }

            /* Roster Grid */
            .form-roster {
                position: absolute;
                border: 1px solid var(--mfc-border);
                background: white;
                overflow: auto;
            }

            .roster-table {
                width: 100%;
                border-collapse: collapse;
            }

            .roster-header {
                background: #e0e0e0;
                position: sticky;
                top: 0;
            }

            .roster-header th {
                padding: 4px 6px;
                border: 1px solid #c0c0c0;
                font-weight: 600;
                font-size: 11px;
            }

            .roster-body td {
                padding: 2px 4px;
                border: 1px solid #c0c0c0;
                font-family: 'Consolas', monospace;
                font-size: 11px;
                vertical-align: top;
            }

            .roster-body tr.current-row {
                background: var(--mfc-field-current);
            }

            .roster-cell {
                padding: 1px;
                vertical-align: top;
                position: relative;
            }

            .roster-cell-input {
                width: 100%;
                border: none;
                background: transparent;
                font-family: inherit;
                font-size: inherit;
                padding: 0;
                outline: none;
            }

            /* MFC-style tickmark field - character boxes with vertical tick lines at bottom */
            .roster-tickmark-container {
                display: inline-flex;
                position: relative;
                align-items: stretch;
                border: 2px inset #808080;
                background: white;
                height: 20px;
            }
            
            .roster-tickmark-container.focused,
            .roster-tickmark-container.current {
                background: var(--mfc-field-current, #90EE90);
            }
            
            .roster-tickmark-input {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 2;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 12px;
                border: none;
                background: transparent;
                outline: none;
                padding: 0 2px;
                letter-spacing: 4px; /* Space between characters to align with tick marks */
            }
            
            .roster-tickmarks {
                display: flex;
                pointer-events: none;
                z-index: 1;
                height: 100%;
            }
            
            /* Each tick represents a character position with a small vertical line at the bottom */
            .roster-tick {
                width: 10px; /* Character width */
                height: 100%;
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 11px;
            }
            
            /* Vertical tick line at the right edge of each character position (except last) */
            .roster-tick:not(:last-child)::after {
                content: '';
                position: absolute;
                right: 0;
                bottom: 0;
                width: 1px;
                height: 25%; /* 1/4 of cell height like MFC */
                background: #808080;
            }
            
            .roster-tick.decimal-point::before {
                content: '.';
                position: absolute;
                bottom: 2px;
                right: -3px;
                font-weight: bold;
                font-size: 12px;
                z-index: 3;
            }
            
            .roster-tickmark-container.focused .roster-tick,
            .roster-tickmark-container.current .roster-tick {
                /* Characters visible on green background */
            }

            /* Roster field container - wraps inputs and tickmarks */
            .roster-field-container {
                display: inline-flex;
                position: relative;
                align-items: stretch;
                border: 2px inset #808080;
                background: white;
                min-height: 18px;
            }
            
            .roster-field-container.current {
                background: var(--mfc-field-current, #90EE90);
            }
            
            /* Fields WITHOUT tick marks - show the input directly */
            .roster-field-container:not(.has-tickmarks) .roster-cell-input {
                border: none;
                background: transparent;
                width: 100%;
                height: 100%;
                padding: 2px 4px;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 11px;
            }
            
            .roster-field-container:not(.has-tickmarks) .roster-cell-input:focus {
                outline: none;
                background: transparent;
            }
            
            /* When has-tickmarks, the input is invisible and positioned over tickmarks */
            .roster-field-container.has-tickmarks {
                padding: 0;
            }
            
            .roster-field-container.has-tickmarks .roster-cell-input {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 2;
                opacity: 0; /* Hidden but still captures input */
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 11px;
            }
            
            .roster-field-container .roster-tickmarks {
                display: flex;
                height: 100%;
                pointer-events: none;
                z-index: 1;
            }
            
            /* MFC-style tick marks - vertical lines at bottom between chars */
            .roster-field-container .roster-tick {
                width: 9px; /* Character width in monospace */
                min-height: 16px;
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 11px;
                padding: 0 1px;
            }
            
            /* Vertical tick line at right edge (between characters) */
            .roster-field-container .roster-tick:not(:last-child)::after {
                content: '';
                position: absolute;
                right: 0;
                bottom: 1px;
                width: 1px;
                height: 5px; /* Short tick line at bottom - 1/4 of cell */
                background: #808080;
            }
            
            .roster-field-container .roster-tick.filled {
                /* Character is filled - display the char */
            }
            
            .roster-field-container.current .roster-tick {
                /* Current field has green background from container */
            }
            
            /* Decimal point indicator */
            .roster-field-container .roster-tick.decimal-point::before {
                content: '.';
                position: absolute;
                bottom: 1px;
                right: -2px;
                font-size: 11px;
                font-weight: bold;
                z-index: 1;
            }
            
            .roster-cell-input {
                width: 100%;
                height: 100%;
                border: 1px solid #ccc;
                padding: 1px 3px;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 11px;
            }
            
            .roster-cell-input:focus {
                outline: none;
                border-color: #0078d4;
                background: var(--mfc-field-current, #90EE90);
            }
            
            .roster-cell-input.numeric {
                text-align: right;
            }
            
            /* Click denied animation for system-controlled mode */
            .roster-cell-input.click-denied,
            .roster-field-container.click-denied {
                animation: click-denied-flash 0.2s ease-in-out;
            }
            
            @keyframes click-denied-flash {
                0% { background-color: #ffcccc; }
                100% { background-color: inherit; }
            }

            /* Current row highlighting */
            .roster-body tr.current-row {
                background: #e8f4fc;
            }
            
            .roster-body tr.current-row td {
                border-color: #0078d4;
            }

            /* Roster Capture Types - Radio Buttons */
            .roster-field-container.capture-radio {
                display: block;
                overflow: visible;
                min-width: 100%;
                position: relative;
            }
            
            /* Selected value display - shown when not active */
            .roster-field-container.capture-radio .selected-value-display,
            .roster-field-container.capture-checkbox .selected-value-display {
                display: block;
                padding: 2px 4px;
                font-size: 11px;
                background: white;
                border: 1px solid #ccc;
                min-height: 18px;
                cursor: pointer;
            }
            
            /* Hide options by default, show only when active */
            .roster-radio-group,
            .roster-checkbox-group {
                display: none !important;
                flex-direction: column;
                gap: 1px;
                padding: 2px;
                max-height: none;
                overflow: visible;
                position: absolute;
                top: 0;
                left: 0;
                z-index: 100;
                background: white;
                border: 1px solid #0078d4;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                min-width: 100%;
            }
            
            /* Show options when container is active/focused */
            .roster-field-container.capture-radio.active .roster-radio-group,
            .roster-field-container.capture-checkbox.active .roster-checkbox-group {
                display: flex !important;
            }
            
            /* Hide value display when active */
            .roster-field-container.capture-radio.active .selected-value-display,
            .roster-field-container.capture-checkbox.active .selected-value-display {
                display: none !important;
            }
            
            .roster-radio-option {
                display: inline-flex;
                align-items: center;
                cursor: pointer;
                padding: 1px 3px;
                border: 1px solid #ccc;
                background: white;
                font-size: 10px;
                border-radius: 2px;
                white-space: nowrap;
            }
            
            .roster-radio-option:hover {
                background: #e8f4fc;
            }
            
            .roster-radio-option input[type="radio"] {
                margin: 0 2px 0 0;
                width: 12px;
                height: 12px;
                flex-shrink: 0;
            }
            
            .roster-radio-option input[type="radio"]:checked + span {
                font-weight: bold;
                color: #0078d4;
            }

            /* Roster Capture Types - Checkboxes */
            .roster-field-container.capture-checkbox {
                display: block;
                overflow: visible;
                min-width: 100%;
                position: relative;
            }
            
            .roster-checkbox-option {
                display: inline-flex;
                align-items: center;
                cursor: pointer;
                padding: 1px 3px;
                border: 1px solid #ccc;
                background: white;
                font-size: 10px;
                border-radius: 2px;
                white-space: nowrap;
            }
            
            .roster-checkbox-option:hover {
                background: #e8f4fc;
            }
            
            .roster-checkbox-option input[type="checkbox"] {
                margin: 0 2px 0 0;
                width: 12px;
                height: 12px;
                flex-shrink: 0;
            }
            
            .roster-checkbox-option input[type="checkbox"]:checked + span {
                font-weight: bold;
                color: #0078d4;
            }

            /* Roster Capture Types - Dropdown/Select */
            .roster-field-container.capture-dropdown {
                display: block;
                width: 100%;
            }
            
            .roster-select {
                width: 100%;
                height: 20px;
                font-size: 11px;
                font-family: inherit;
                border: 1px solid #ccc;
                background: white;
                padding: 0 2px;
            }
            
            .roster-select:focus {
                outline: none;
                border-color: #0078d4;
                background: var(--mfc-field-current, #90EE90);
            }

            /* No-responses indicator for capture types */
            .roster-field-container.no-responses {
                position: relative;
            }
            
            .roster-field-container.no-responses::before {
                content: attr(title);
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 9px;
                color: #888;
                background: #f5f5f5;
                border: 1px dashed #ccc;
                pointer-events: none;
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
                padding: 2px;
            }
            
            .roster-field-container.capture-radio.no-responses::before {
                content: ' Radio';
            }
            
            .roster-field-container.capture-checkbox.no-responses::before {
                content: ' Check';
            }
            
            .roster-field-container.capture-dropdown.no-responses::before {
                content: ' Select';
            }

            .roster-row-number {
                background: #e0e0e0;
                font-weight: 600;
                text-align: center;
                width: 30px;
            }

            /* CAPI Panel - Windows MFC Style */
            .capi-panel {
                border-bottom: 2px solid #808080;
                background: linear-gradient(180deg, #ffffdd 0%, #ffffaa 100%);
                display: none;
                flex-direction: column;
                min-height: 80px;
            }

            .capi-panel.visible {
                display: flex;
            }

            /* CAPI Question Header - Yellow like Windows MFC */
            .capi-question-header {
                background: transparent;
                padding: 8px 12px;
                min-height: 60px;
            }

            .capi-question-container {
                width: 100%;
                height: 120px;
            }

            .capi-question-iframe {
                width: 100%;
                height: 100%;
                border: none;
                background: transparent;
            }

            .capi-question {
                font-size: 13px;
                font-weight: 600;
                color: #000080;
                line-height: 1.4;
            }

            .capi-help {
                font-size: 11px;
                color: #333;
                font-style: italic;
                margin-top: 4px;
            }

            /* CAPI Response List - Windows ListBox Style */
            .capi-responses-container {
                background: white;
                border-top: 1px solid #808080;
                max-height: 150px;
                overflow-y: auto;
            }

            .capi-responses {
                display: flex;
                flex-direction: column;
            }

            .capi-response {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 4px 8px;
                background: white;
                border-bottom: 1px solid #e0e0e0;
                cursor: pointer;
                font-size: 12px;
            }

            .capi-response:hover {
                background: #cce8ff;
            }

            .capi-response.selected {
                background: #0078d7;
                color: white;
            }

            .capi-response.selected .capi-response-code,
            .capi-response.selected .capi-response-label {
                color: white;
            }

            .capi-response-code {
                font-family: 'Consolas', 'Courier New', monospace;
                font-weight: 600;
                min-width: 50px;
                color: #000080;
            }

            .capi-response-label {
                flex: 1;
            }

            /* Status Bar */
            .mfc-statusbar {
                display: flex;
                height: 22px;
                background: var(--mfc-window-bg);
                border-top: 1px solid var(--mfc-border);
                padding: 0 4px;
                align-items: center;
                font-size: 11px;
            }

            .status-section {
                padding: 0 8px;
                border-right: 1px solid var(--mfc-border);
            }

            .status-section:last-child { border-right: none; }
            .status-progress { flex: 1; text-align: right; }

            /* Buttons */
            .btn {
                padding: 6px 16px;
                font-size: 13px;
                border: 1px solid var(--mfc-border);
                background: var(--mfc-btn-face);
                cursor: pointer;
            }

            .btn:hover { background: white; }
            .btn:active { background: #c0c0c0; }

            .btn-primary {
                background: var(--mfc-selection);
                color: white;
                border-color: var(--mfc-selection);
            }

            .btn-primary:hover { background: #005a9e; }

            /* Modal */
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            }

            .modal {
                background: var(--mfc-window-bg);
                border: 2px solid var(--mfc-border);
                box-shadow: 4px 4px 10px rgba(0,0,0,0.3);
                min-width: 300px;
            }

            .modal-titlebar {
                background: var(--mfc-selection);
                color: white;
                padding: 4px 8px;
                font-weight: 600;
                display: flex;
                justify-content: space-between;
            }

            .modal-close {
                cursor: pointer;
                padding: 0 4px;
            }

            .modal-content { padding: 16px; }

            .modal-buttons {
                display: flex;
                justify-content: flex-end;
                gap: 8px;
                padding: 8px 16px 16px;
            }

            /* CSPro Native Dialog Overlay */
            .dialog-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 10000;
            }

            .dialog-backdrop {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
            }

            .dialog-container {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--mfc-window-bg);
                border: 2px solid var(--mfc-border);
                box-shadow: 4px 4px 10px rgba(0,0,0,0.3);
                min-width: 300px;
                max-width: 80vw;
                max-height: 80vh;
                overflow: auto;
            }

            .dialog-iframe {
                border: none;
                width: 100%;
                min-height: 150px;
            }

            /* Simple message dialog (fallback) */
            .dialog-message {
                padding: 16px 20px;
            }

            .dialog-message-title {
                background: var(--mfc-selection);
                color: white;
                padding: 6px 10px;
                font-weight: 600;
                margin: -2px -2px 0 -2px;
            }

            .dialog-message-text {
                padding: 16px 0;
                line-height: 1.4;
            }

            .dialog-message-buttons {
                display: flex;
                justify-content: flex-end;
                gap: 8px;
                padding-top: 8px;
            }

            .dialog-message-buttons button {
                min-width: 75px;
                padding: 4px 12px;
                background: var(--mfc-control-bg);
                border: 1px solid var(--mfc-border);
                cursor: pointer;
            }

            .dialog-message-buttons button:hover {
                background: var(--mfc-disabled);
            }

            .dialog-message-buttons button.default-button {
                border: 2px solid var(--mfc-selection);
            }

            /* Choice dialog styles */
            .choice-list {
                max-height: 200px;
                overflow-y: auto;
                border: 1px solid var(--mfc-border);
                margin: 8px 0;
            }

            .choice-item {
                padding: 6px 10px;
                cursor: pointer;
                border-bottom: 1px solid var(--mfc-disabled);
            }

            .choice-item:last-child {
                border-bottom: none;
            }

            .choice-item:hover {
                background: var(--mfc-disabled);
            }

            .choice-item.selected {
                background: var(--mfc-selection);
                color: white;
            }

            /* ComboBox Dialog (editable dropdown with search) */
            .dialog-combobox {
                background: var(--mfc-window-bg);
                border: 1px solid var(--mfc-border);
                border-radius: 4px;
                box-shadow: 0 4px 16px rgba(0,0,0,0.2);
                min-width: 350px;
                max-width: 500px;
                max-height: 80vh;
                display: flex;
                flex-direction: column;
            }

            .dialog-combobox-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                background: var(--mfc-menubar);
                border-bottom: 1px solid var(--mfc-border);
            }

            .dialog-combobox-title {
                font-weight: bold;
                color: var(--mfc-text);
            }

            .dialog-close-btn {
                background: none;
                border: none;
                font-size: 20px;
                cursor: pointer;
                color: var(--mfc-text);
                padding: 0 4px;
                line-height: 1;
            }

            .dialog-close-btn:hover {
                color: #c00;
            }

            .dialog-combobox-input-row {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px;
                border-bottom: 1px solid var(--mfc-border);
                background: #f9f9f9;
            }

            .dialog-combobox-input-row label {
                font-size: 12px;
                color: var(--mfc-text);
                white-space: nowrap;
            }

            .dialog-combobox-input {
                flex: 1;
                padding: 6px 10px;
                font-size: 14px;
                border: 2px inset #808080;
                font-family: 'Consolas', monospace;
            }

            .dialog-combobox-input:focus {
                outline: none;
                border-color: var(--mfc-selection);
            }

            .dialog-combobox-list-container {
                flex: 1;
                overflow: auto;
                max-height: 300px;
            }

            .dialog-combobox-table {
                width: 100%;
                border-collapse: collapse;
                font-size: 12px;
            }

            .dialog-combobox-table thead {
                position: sticky;
                top: 0;
                background: var(--mfc-menubar);
                z-index: 1;
            }

            .dialog-combobox-table th {
                text-align: left;
                padding: 6px 10px;
                border-bottom: 1px solid var(--mfc-border);
                font-weight: bold;
            }

            .dialog-combobox-table td {
                padding: 6px 10px;
                border-bottom: 1px solid #eee;
            }

            .combobox-row {
                cursor: pointer;
            }

            .combobox-row:hover {
                background: #e8f4fc;
            }

            .combobox-row.selected {
                background: var(--mfc-selection);
                color: white;
            }

            .dialog-combobox-buttons {
                display: flex;
                justify-content: flex-end;
                gap: 8px;
                padding: 12px;
                border-top: 1px solid var(--mfc-border);
            }

            .dialog-btn {
                min-width: 75px;
                padding: 6px 16px;
                background: var(--mfc-control-bg);
                border: 1px solid var(--mfc-border);
                cursor: pointer;
                font-size: 12px;
            }

            .dialog-btn:hover {
                background: var(--mfc-disabled);
            }

            .dialog-btn-ok {
                border: 2px solid var(--mfc-selection);
            }

            /* Value Set Dialog (like MFC CSEntry popup) */
            .valueset-dialog {
                background: var(--mfc-window-bg);
                border: 1px solid var(--mfc-border);
                border-radius: 4px;
                box-shadow: 0 4px 16px rgba(0,0,0,0.2);
                min-width: 300px;
                max-width: 90vw;
                max-height: 80vh;
                display: flex;
                flex-direction: column;
            }

            .valueset-dialog-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                background: var(--mfc-menubar);
                border-bottom: 1px solid var(--mfc-border);
                color: var(--mfc-text);
                font-weight: bold;
            }

            .valueset-dialog-title {
                flex: 1;
            }

            .valueset-dialog-close {
                background: none;
                border: none;
                font-size: 20px;
                cursor: pointer;
                color: var(--mfc-text);
                padding: 0 4px;
                line-height: 1;
            }

            .valueset-dialog-close:hover {
                color: #c00;
            }

            .valueset-dialog-body {
                flex: 1;
                overflow-y: auto;
                padding: 0;
                max-height: 50vh;
            }

            .valueset-table {
                width: 100%;
                border-collapse: collapse;
            }

            .valueset-table thead {
                position: sticky;
                top: 0;
                background: #343a40;
                color: white;
                z-index: 1;
            }

            .valueset-table th {
                padding: 8px 12px;
                text-align: left;
                font-weight: bold;
            }

            .valueset-table td {
                padding: 6px 12px;
                border-bottom: 1px solid var(--mfc-border);
            }

            .valueset-row {
                cursor: pointer;
            }

            .valueset-row:hover {
                background: var(--mfc-disabled);
            }

            .valueset-row:focus {
                outline: 2px solid var(--mfc-selection);
                outline-offset: -2px;
            }

            .valueset-row.selected {
                background: rgba(0, 127, 255, 0.3);
            }

            .valueset-code {
                font-family: monospace;
                white-space: nowrap;
                width: 60px;
            }

            .valueset-label {
                flex: 1;
            }

            .valueset-dialog-footer {
                display: flex;
                justify-content: flex-end;
                gap: 8px;
                padding: 10px 12px;
                border-top: 1px solid var(--mfc-border);
                background: var(--mfc-menubar);
            }

            .valueset-btn {
                padding: 6px 16px;
                border: 1px solid var(--mfc-border);
                background: var(--mfc-button);
                cursor: pointer;
                border-radius: 2px;
            }

            .valueset-btn:hover {
                background: var(--mfc-disabled);
            }

            .valueset-btn-ok {
                background: var(--mfc-selection);
                color: white;
                border-color: var(--mfc-selection);
            }

            .valueset-btn-ok:hover {
                background: #0056b3;
            }

            /* Menu Dropdown */
            .menu-item {
                position: relative;
            }

            .menu-dropdown {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                background: var(--mfc-window-bg);
                border: 1px solid var(--mfc-border);
                box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
                min-width: 180px;
                z-index: 1000;
            }

            .menu-item:hover .menu-dropdown,
            .menu-item.active .menu-dropdown {
                display: block;
            }

            .menu-dropdown-item {
                padding: 6px 20px;
                cursor: pointer;
                white-space: nowrap;
                color: var(--mfc-text);
                background: var(--mfc-window-bg);
            }

            .menu-dropdown-item:hover {
                background: var(--mfc-selection);
                color: var(--mfc-selection-text);
            }

            .menu-dropdown-item.menu-label {
                font-weight: bold;
                font-size: 11px;
                color: #666;
                cursor: default;
                padding-top: 8px;
            }
            .menu-dropdown-item.menu-label:hover {
                background: var(--mfc-window-bg);
                color: #666;
            }

            .menu-check {
                display: inline-block;
                width: 16px;
                text-align: center;
                margin-right: 4px;
            }

            .menu-dropdown-sep {
                height: 1px;
                background: var(--mfc-border);
                margin: 4px 0;
            }

            /* Welcome Screen App Sources */
            .app-sources {
                margin-top: 30px;
                text-align: left;
                max-width: 500px;
            }

            .app-sources h3 {
                margin: 0 0 15px 0;
                color: #666;
                font-size: 14px;
                font-weight: normal;
            }

            .source-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            .source-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 16px;
                border: 1px solid var(--mfc-border);
                background: white;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .source-btn:hover {
                border-color: var(--mfc-selection);
                background: #f0f7ff;
            }

            .source-icon {
                font-size: 28px;
                margin-bottom: 8px;
            }

            .source-label {
                font-weight: 600;
                margin-bottom: 4px;
            }

            .source-desc {
                font-size: 11px;
                color: #888;
                text-align: center;
            }

            /* Application Loader Dialog */
            .app-loader-dialog {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--mfc-window-bg);
                border: 2px solid var(--mfc-border);
                box-shadow: 4px 4px 15px rgba(0,0,0,0.3);
                width: 600px;
                max-width: 90vw;
                max-height: 80vh;
                display: flex;
                flex-direction: column;
            }

            .app-loader-header {
                background: var(--mfc-selection);
                color: white;
                padding: 10px 15px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-weight: 600;
            }

            .dialog-close-btn {
                background: none;
                border: none;
                color: white;
                font-size: 20px;
                cursor: pointer;
                padding: 0 5px;
            }

            .dialog-close-btn:hover {
                background: rgba(255,255,255,0.2);
            }

            .app-loader-tabs {
                display: flex;
                background: #e0e0e0;
                border-bottom: 1px solid var(--mfc-border);
            }

            .app-loader-tab {
                padding: 10px 20px;
                border: none;
                background: transparent;
                cursor: pointer;
                font-size: 13px;
                border-bottom: 2px solid transparent;
            }

            .app-loader-tab:hover {
                background: #d0d0d0;
            }

            .app-loader-tab.active {
                background: white;
                border-bottom-color: var(--mfc-selection);
            }

            .app-loader-content {
                flex: 1;
                overflow: hidden;
            }

            .app-loader-panel {
                display: none;
                height: 350px;
                overflow-y: auto;
                padding: 15px;
            }

            .app-loader-panel.active {
                display: block;
            }

            .app-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .app-item {
                display: flex;
                align-items: center;
                padding: 12px;
                background: white;
                border: 1px solid var(--mfc-border);
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.15s;
            }

            .app-item:hover {
                border-color: var(--mfc-selection);
                background: #f0f7ff;
            }

            .app-item-icon {
                font-size: 24px;
                margin-right: 12px;
            }

            .app-item-info {
                flex: 1;
            }

            .app-item-name {
                font-weight: 600;
                margin-bottom: 2px;
            }

            .app-item-meta {
                font-size: 11px;
                color: #888;
            }

            .app-item-action {
                padding: 6px 12px;
                background: var(--mfc-selection);
                color: white;
                border: none;
                border-radius: 3px;
                cursor: pointer;
                font-size: 12px;
            }

            .loading-indicator, .empty-state {
                text-align: center;
                padding: 40px;
                color: #888;
            }

            /* CSWeb Config */
            .csweb-config {
                display: flex;
                gap: 10px;
                margin-bottom: 15px;
                align-items: center;
            }

            .csweb-config label {
                white-space: nowrap;
            }

            .csweb-config input {
                flex: 1;
                padding: 6px 10px;
                border: 1px solid var(--mfc-border);
            }

            /* Upload Zone */
            .upload-zone {
                border: 2px dashed var(--mfc-border);
                border-radius: 8px;
                padding: 40px 20px;
                text-align: center;
                cursor: pointer;
                transition: all 0.2s;
            }

            .upload-zone:hover, .upload-zone.dragover {
                border-color: var(--mfc-selection);
                background: #f0f7ff;
            }

            .upload-icon {
                font-size: 48px;
                margin-bottom: 15px;
            }

            .upload-text {
                font-size: 16px;
                margin-bottom: 8px;
            }

            .upload-hint {
                font-size: 12px;
                color: #888;
                margin-bottom: 15px;
            }

            .upload-buttons {
                display: flex;
                gap: 10px;
                justify-content: center;
            }

            .upload-preview {
                border: 1px solid var(--mfc-border);
                border-radius: 4px;
                background: white;
            }

            .upload-preview-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px 15px;
                background: #f5f5f5;
                border-bottom: 1px solid var(--mfc-border);
            }

            .upload-file-list {
                max-height: 200px;
                overflow-y: auto;
                padding: 10px 15px;
            }

            .upload-file-item {
                display: flex;
                align-items: center;
                padding: 6px 0;
                border-bottom: 1px solid #eee;
            }

            .upload-file-item:last-child {
                border-bottom: none;
            }

            .upload-file-icon {
                margin-right: 8px;
            }

            .upload-file-name {
                flex: 1;
            }

            .upload-file-size {
                font-size: 11px;
                color: #888;
            }

            #btnUploadApp {
                width: 100%;
                margin-top: 15px;
                padding: 10px;
            }

            .btn-small {
                padding: 4px 10px;
                font-size: 12px;
            }

            .btn-secondary {
                background: white;
                border: 1px solid var(--mfc-border);
                padding: 6px 12px;
                cursor: pointer;
            }

            .btn-secondary:hover {
                background: #f0f0f0;
            }
        `;
    }

    _cacheElements() {
        const $ = (sel) => this.shadowRoot.querySelector(sel);
        this.$ = {
            treePanel: $('#treePanel'),
            treeContent: $('#treeContent'),
            splitter: $('#splitter'),
            formTitle: $('#formTitle'),
            formTabs: $('#formTabs'),
            formCanvas: $('#formCanvas'),
            formContainer: $('#formContainer'),
            capiPanel: $('#capiPanel'),
            statusField: $('#statusField'),
            statusOcc: $('#statusOcc'),
            statusMode: $('#statusMode'),
            statusProgress: $('#statusProgress'),
            btnLoadApp: $('#btnLoadApp'),
            welcomeMessage: $('#welcomeMessage'),
            // Dialog elements
            dialogOverlay: $('#dialogOverlay'),
            dialogContainer: $('#dialogContainer'),
            dialogIframe: $('#dialogIframe'),
            // App Loader elements
            appLoaderOverlay: $('#appLoaderOverlay'),
            appLoaderClose: $('#appLoaderClose'),
            serverAppList: $('#serverAppList'),
            assetsAppList: $('#assetsAppList'),
            cswebAppList: $('#cswebAppList'),
            cswebUrl: $('#cswebUrl'),
            cswebConnect: $('#cswebConnect'),
            uploadZone: $('#uploadZone'),
            folderInput: $('#folderInput'),
            fileInput: $('#fileInput'),
            uploadPreview: $('#uploadPreview'),
            uploadAppName: $('#uploadAppName'),
            uploadFileList: $('#uploadFileList'),
            btnSelectFolder: $('#btnSelectFolder'),
            btnSelectFiles: $('#btnSelectFiles'),
            btnClearUpload: $('#btnClearUpload'),
            btnUploadApp: $('#btnUploadApp'),
        };
    }

    _setupEventListeners() {
        // Menu bar
        this.shadowRoot.querySelector('.mfc-menubar').addEventListener('click', (e) => {
            const menuItem = e.target.closest('.menu-dropdown-item');
            if (menuItem) {
                this._handleMenuAction(menuItem.dataset.action);
                // Close menu
                this.shadowRoot.querySelectorAll('.menu-item').forEach(m => m.classList.remove('active'));
            }
        });

        // Toolbar buttons
        this.shadowRoot.querySelector('.mfc-toolbar').addEventListener('click', (e) => {
            const btn = e.target.closest('.toolbar-btn');
            if (btn) this._handleToolbarAction(btn.dataset.action);
        });

        // Load app button
        this.$.btnLoadApp?.addEventListener('click', () => {
            this._showAppLoader();
        });

        // Welcome screen source buttons
        this.shadowRoot.querySelectorAll('.source-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const source = btn.dataset.source;
                this._showAppLoader(source);
            });
        });

        // App Loader Dialog
        this.$.appLoaderClose?.addEventListener('click', () => this._hideAppLoader());
        
        // App Loader tabs
        this.shadowRoot.querySelectorAll('.app-loader-tab').forEach(tab => {
            tab.addEventListener('click', () => this._switchAppLoaderTab(tab.dataset.tab));
        });

        // CSWeb connect
        this.$.cswebConnect?.addEventListener('click', () => this._loadCSWebApps());

        // Upload zone
        this._setupUploadZone();

        // Splitter resize
        this.$.splitter.addEventListener('mousedown', (e) => {
            this.isResizing = true;
            document.body.style.cursor = 'col-resize';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!this.isResizing) return;
            const rect = this.getBoundingClientRect();
            const newWidth = Math.max(150, Math.min(400, e.clientX - rect.left));
            this.$.treePanel.style.width = newWidth + 'px';
        });

        document.addEventListener('mouseup', () => {
            this.isResizing = false;
            document.body.style.cursor = '';
        });

        // Keyboard shortcuts
        this.addEventListener('keydown', (e) => this._handleKeyDown(e));
        
        // Click outside handler to deactivate inline radio/checkbox dropdowns
        this.shadowRoot.addEventListener('click', (e) => {
            // If clicked outside any active inline container, deactivate all
            const clickedContainer = e.target.closest('.roster-field-container.capture-radio, .roster-field-container.capture-checkbox');
            if (!clickedContainer) {
                this.shadowRoot.querySelectorAll('.roster-field-container.active').forEach(c => {
                    c.classList.remove('active');
                });
            }
        });
    }

    _handleMenuAction(action) {
        switch (action) {
            case 'open-dialog': this._showAppLoader(); break;
            case 'open-server': this._showAppLoader('server'); break;
            case 'open-assets': this._showAppLoader('assets'); break;
            case 'open-csweb': this._showAppLoader('csweb'); break;
            case 'upload-folder': this._showAppLoader('upload'); break;
            case 'new': this.addCase(); break;
            case 'save': this.saveCase(); break;
            case 'partial-save': this.partialSave(); break;
            case 'close': this._closeApplication(); break;
            // Options menu
            case 'capture-inline': this._setCaptureDisplayMode('inline'); break;
            case 'capture-dialog': this._setCaptureDisplayMode('dialog'); break;
        }
    }

    /**
     * Set the capture type display mode (inline or dialog)
     * @param {string} mode - 'inline' for inline display in roster, 'dialog' for select dialog popup
     */
    _setCaptureDisplayMode(mode) {
        this._captureDisplayMode = mode;
        // Update menu checkmarks
        const checkInline = this.shadowRoot.getElementById('checkCaptureInline');
        const checkDialog = this.shadowRoot.getElementById('checkCaptureDialog');
        if (checkInline) checkInline.textContent = mode === 'inline' ? '' : '';
        if (checkDialog) checkDialog.textContent = mode === 'dialog' ? '' : '';
        // Save preference
        try {
            localStorage.setItem('csentry-capture-display-mode', mode);
        } catch (e) { /* ignore storage errors */ }
        console.log('[MFC] Capture display mode set to:', mode);
        
        // If switching modes and we have a current field, update the display
        if (this.currentField) {
            const field = this.currentField;
            const CT = CSEntryMFCView.CAPTURE_TYPES;
            const captureType = field.captureType ?? CT.TextBox;
            const responses = field.responses || [];
            const isRosterField = field.indexes && field.indexes.length > 0 && field.indexes[0] > 0;
            
            // Check if this field type is affected by display mode
            const affectedByMode = responses.length > 0 && 
                (captureType === CT.RadioButton || captureType === CT.CheckBox);
            
            if (affectedByMode) {
                if (isRosterField) {
                    // For roster fields, we need to re-render the entire roster
                    // to show inline radio buttons or tick marks
                    console.log('[MFC] Roster field display mode changed, refreshing roster');
                    this._refreshCurrentRoster();
                } else {
                    // For non-roster fields, update the field element
                    console.log('[MFC] Updating current field display:', field.name);
                    this._updateFieldFromEngine(field);
                }
            }
        }
    }
    
    /**
     * Refresh the current roster to reflect display mode changes
     * This re-renders roster cells with the new inline/dialog mode
     */
    _refreshCurrentRoster() {
        if (!this.currentField || !this.currentPageData) return;
        
        const field = this.currentField;
        // Find the roster containing this field
        const rosters = this.currentPageData.rosters || [];
        let targetRoster = null;
        
        for (const roster of rosters) {
            const rosterFields = roster.fields || [];
            const found = rosterFields.find(f => f.name === field.name);
            if (found) {
                targetRoster = roster;
                break;
            }
        }
        
        if (!targetRoster) {
            console.log('[MFC] No roster found for field:', field.name);
            return;
        }
        
        // Find and re-render the roster
        const rosterContainer = this.$.formContainer.querySelector(`[data-roster-name="${targetRoster.name}"]`);
        if (rosterContainer) {
            console.log('[MFC] Re-rendering roster:', targetRoster.name);
            const newRoster = this._createRosterElement(targetRoster);
            rosterContainer.parentNode.replaceChild(newRoster, rosterContainer);
            
            // Re-focus on the current field cell after re-rendering
            const occurrence = field.indexes?.[0] || 1;
            const rowIdx = occurrence - 1;
            setTimeout(() => {
                const newCell = this.$.formContainer.querySelector(
                    `[data-field-name="${field.name}"][data-occurrence="${occurrence}"], ` +
                    `[data-field-name="${field.name}"][data-row-index="${rowIdx}"]`
                );
                if (newCell) {
                    const input = newCell.querySelector('input, select');
                    if (input) input.focus();
                }
            }, 50);
        }
    }

    /**
     * Get the current capture type display mode
     * @returns {string} 'inline' or 'dialog'
     */
    _getCaptureDisplayMode() {
        if (!this._captureDisplayMode) {
            // Load from localStorage or default to 'inline'
            try {
                this._captureDisplayMode = localStorage.getItem('csentry-capture-display-mode') || 'inline';
            } catch (e) {
                this._captureDisplayMode = 'inline';
            }
        }
        return this._captureDisplayMode;
    }

    /**
     * Initialize capture display mode and update menu checkmarks on startup
     */
    _initCaptureDisplayMode() {
        const mode = this._getCaptureDisplayMode();
        const checkInline = this.shadowRoot.getElementById('checkCaptureInline');
        const checkDialog = this.shadowRoot.getElementById('checkCaptureDialog');
        if (checkInline) checkInline.textContent = mode === 'inline' ? '' : '';
        if (checkDialog) checkDialog.textContent = mode === 'dialog' ? '' : '';
    }

    _handleToolbarAction(action) {
        switch (action) {
            case 'new': this.addCase(); break;
            case 'open': this._showAppLoader(); break;
            case 'save': this.saveCase(); break;
            case 'partial-save': this.partialSave(); break;
            case 'add': this.addCase(); break;
            case 'modify': this._showModifyDialog(); break;
            case 'delete': this.deleteCase(); break;
            case 'prev': this.previousField(); break;
            case 'next': this.nextField(); break;
            case 'endgrp': this.endGroup(); break;
            case 'find': this._showFindDialog(); break;
            case 'goto': this._showGoToDialog(); break;
            case 'note': this._showNoteDialog(); break;
        }
    }

    // ========================================================================
    // Application Loader
    // ========================================================================

    _showAppLoader(initialTab = 'server') {
        this.$.appLoaderOverlay.style.display = 'block';
        this._switchAppLoaderTab(initialTab);
    }

    _hideAppLoader() {
        this.$.appLoaderOverlay.style.display = 'none';
        this._pendingUploadFiles = null;
    }

    _switchAppLoaderTab(tabName) {
        // Update tab buttons
        this.shadowRoot.querySelectorAll('.app-loader-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.tab === tabName);
        });
        
        // Update panels
        this.shadowRoot.querySelectorAll('.app-loader-panel').forEach(panel => {
            panel.classList.toggle('active', panel.id === `panel${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
        });

        // Load content for the tab
        switch (tabName) {
            case 'server': this._loadServerApps(); break;
            case 'assets': this._loadAssetsApps(); break;
        }
    }

    async _loadServerApps() {
        this.$.serverAppList.innerHTML = '<div class="loading-indicator">Loading applications...</div>';
        
        try {
            const response = await fetch('/api/applications');
            if (!response.ok) throw new Error('Failed to load applications');
            
            const data = await response.json();
            const apps = data.applications || data || [];
            
            if (!Array.isArray(apps) || apps.length === 0) {
                this.$.serverAppList.innerHTML = '<div class="empty-state">No applications on server.<br>Upload an application to get started.</div>';
                return;
            }

            this.$.serverAppList.innerHTML = apps.map(app => `
                <div class="app-item" data-app="${app.name}" data-source="server">
                    <span class="app-item-icon"></span>
                    <div class="app-item-info">
                        <div class="app-item-name">${this._escapeHtml(app.name)}</div>
                        <div class="app-item-meta">${app.pffFiles?.length || 0} PFF file(s)</div>
                    </div>
                    <button class="app-item-action">Load</button>
                </div>
            `).join('');

            // Add click handlers
            this.$.serverAppList.querySelectorAll('.app-item').forEach(item => {
                item.addEventListener('click', () => this._loadAppFromServer(item.dataset.app));
            });
        } catch (error) {
            console.error('Error loading server apps:', error);
            this.$.serverAppList.innerHTML = '<div class="empty-state">Failed to load applications.<br>Check server connection.</div>';
        }
    }

    async _loadAssetsApps() {
        this.$.assetsAppList.innerHTML = '<div class="loading-indicator">Loading assets...</div>';
        
        try {
            // Assets are embedded in the WASM virtual filesystem
            // First ensure engine is initialized to access FS
            if (!await this.initEngine()) {
                this.$.assetsAppList.innerHTML = '<div class="empty-state">Failed to initialize engine.</div>';
                return;
            }
            
            // Get list of embedded applications from WASM engine
            let assets = [];
            if (this.engine && typeof this.engine.listEmbeddedApplications === 'function') {
                const result = this.engine.listEmbeddedApplications();
                if (result && result.applications) {
                    assets = result.applications;
                }
            }
            
            // If engine doesn't have list method, try to read from known WASM FS paths
            if (assets.length === 0 && this._wasmModule && this._wasmModule.FS) {
                try {
                    const FS = this._wasmModule.FS;
                    // Check common paths for embedded applications
                    // CSPro WASM embeds to /Assets/examples/
                    const paths = ['/Assets/examples', '/Assets', '/applications', '/assets', '/data/applications'];
                    for (const basePath of paths) {
                        try {
                            const entries = FS.readdir(basePath);
                            console.log(`[Assets] Found ${entries.length} entries in ${basePath}:`, entries);
                            // First check for PFF files directly in this directory
                            const pffFiles = entries.filter(f => f.toLowerCase().endsWith('.pff'));
                            for (const pffFile of pffFiles) {
                                const appName = pffFile.replace(/\.pff$/i, '');
                                if (!assets.find(a => a.name === appName)) {
                                    assets.push({ name: appName, path: basePath, pffFile: pffFile });
                                }
                            }
                            // Also check subdirectories
                            for (const entry of entries) {
                                if (entry !== '.' && entry !== '..') {
                                    const fullPath = `${basePath}/${entry}`;
                                    try {
                                        const stat = FS.stat(fullPath);
                                        if (FS.isDir(stat.mode)) {
                                            // Check if it has a PFF file
                                            const subEntries = FS.readdir(fullPath);
                                            const subPff = subEntries.find(f => f.toLowerCase().endsWith('.pff'));
                                            if (subPff) {
                                                assets.push({ name: entry, path: fullPath, pffFile: subPff });
                                            }
                                        }
                                    } catch (e) { /* ignore */ }
                                }
                            }
                        } catch (e) { 
                            console.log(`[Assets] Path ${basePath} not found or error:`, e.message);
                        }
                    }
                } catch (e) {
                    console.log('FS not available or error reading:', e);
                }
            }
            
            if (assets.length === 0) {
                this.$.assetsAppList.innerHTML = '<div class="empty-state">No embedded applications found.<br>Applications can be embedded during WASM build.</div>';
                return;
            }

            this.$.assetsAppList.innerHTML = assets.map(app => `
                <div class="app-item" data-app="${app.name}" data-path="${app.path || ''}" data-pff="${app.pffFile || ''}" data-source="assets">
                    <span class="app-item-icon"></span>
                    <div class="app-item-info">
                        <div class="app-item-name">${this._escapeHtml(app.name)}</div>
                        <div class="app-item-meta">Embedded application</div>
                    </div>
                    <button class="app-item-action">Load</button>
                </div>
            `).join('');

            this.$.assetsAppList.querySelectorAll('.app-item').forEach(item => {
                item.addEventListener('click', () => this._loadAppFromAssets(item.dataset.app, item.dataset.path, item.dataset.pff));
            });
        } catch (error) {
            console.error('Error loading assets:', error);
            this.$.assetsAppList.innerHTML = '<div class="empty-state">Error loading embedded applications.</div>';
        }
    }

    async _loadCSWebApps() {
        const url = this.$.cswebUrl.value.trim();
        if (!url) {
            alert('Please enter a CSWeb server URL');
            return;
        }

        this.$.cswebAppList.innerHTML = '<div class="loading-indicator">Connecting to CSWeb...</div>';

        try {
            // Try to connect to CSWeb server
            const response = await fetch(`${url}/api/dictionaries`, {
                mode: 'cors',
                headers: { 'Accept': 'application/json' }
            });
            
            if (!response.ok) throw new Error('Failed to connect to CSWeb');
            
            const dictionaries = await response.json();
            
            if (!dictionaries || dictionaries.length === 0) {
                this.$.cswebAppList.innerHTML = '<div class="empty-state">No dictionaries found on CSWeb server.</div>';
                return;
            }

            this.$.cswebAppList.innerHTML = dictionaries.map(dict => `
                <div class="app-item" data-app="${dict.name}" data-source="csweb" data-url="${url}">
                    <span class="app-item-icon"></span>
                    <div class="app-item-info">
                        <div class="app-item-name">${this._escapeHtml(dict.label || dict.name)}</div>
                        <div class="app-item-meta">CSWeb Dictionary</div>
                    </div>
                    <button class="app-item-action">Sync</button>
                </div>
            `).join('');

            this.$.cswebAppList.querySelectorAll('.app-item').forEach(item => {
                item.addEventListener('click', () => this._syncFromCSWeb(item.dataset.app, item.dataset.url));
            });
        } catch (error) {
            console.error('Error connecting to CSWeb:', error);
            this.$.cswebAppList.innerHTML = '<div class="empty-state">Failed to connect to CSWeb server.<br>Check URL and try again.</div>';
        }
    }

    _setupUploadZone() {
        const uploadZone = this.$.uploadZone;
        const folderInput = this.$.folderInput;
        const fileInput = this.$.fileInput;

        // Drag and drop
        uploadZone?.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone?.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone?.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            this._handleDroppedFiles(e.dataTransfer);
        });

        // Button clicks
        this.$.btnSelectFolder?.addEventListener('click', (e) => {
            e.stopPropagation();
            folderInput.click();
        });

        this.$.btnSelectFiles?.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInput.click();
        });

        // File inputs
        folderInput?.addEventListener('change', (e) => {
            this._handleSelectedFiles(Array.from(e.target.files));
        });

        fileInput?.addEventListener('change', (e) => {
            this._handleSelectedFiles(Array.from(e.target.files));
        });

        // Clear and upload buttons
        this.$.btnClearUpload?.addEventListener('click', () => {
            this._pendingUploadFiles = null;
            this.$.uploadZone.style.display = 'block';
            this.$.uploadPreview.style.display = 'none';
        });

        this.$.btnUploadApp?.addEventListener('click', () => this._uploadAndLoadApp());
    }

    async _handleDroppedFiles(dataTransfer) {
        const items = dataTransfer.items;
        const files = [];

        // Handle folder drops
        for (const item of items) {
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry?.();
                if (entry) {
                    if (entry.isDirectory) {
                        const dirFiles = await this._readDirectory(entry);
                        files.push(...dirFiles);
                    } else {
                        files.push(item.getAsFile());
                    }
                } else {
                    files.push(item.getAsFile());
                }
            }
        }

        this._handleSelectedFiles(files);
    }

    async _readDirectory(dirEntry, path = '') {
        const files = [];
        const reader = dirEntry.createReader();
        
        return new Promise((resolve) => {
            const readEntries = () => {
                reader.readEntries(async (entries) => {
                    if (entries.length === 0) {
                        resolve(files);
                        return;
                    }
                    
                    for (const entry of entries) {
                        if (entry.isFile) {
                            const file = await new Promise(res => entry.file(res));
                            // Store relative path
                            file.relativePath = path + entry.name;
                            files.push(file);
                        } else if (entry.isDirectory) {
                            const subFiles = await this._readDirectory(entry, path + entry.name + '/');
                            files.push(...subFiles);
                        }
                    }
                    
                    readEntries();
                });
            };
            readEntries();
        });
    }

    _handleSelectedFiles(files) {
        // Filter to CSPro files
        const validExtensions = ['.pff', '.pen', '.dcf', '.fmf', '.ent', '.qsf', '.dat', '.csdb'];
        const csproFiles = files.filter(f => {
            const ext = '.' + f.name.split('.').pop().toLowerCase();
            return validExtensions.includes(ext);
        });

        if (csproFiles.length === 0) {
            alert('No CSPro application files found. Please select a folder containing .pff, .pen, .dcf, .fmf files.');
            return;
        }

        this._pendingUploadFiles = csproFiles;
        
        // Find app name from PFF file
        const pffFile = csproFiles.find(f => f.name.toLowerCase().endsWith('.pff'));
        const appName = pffFile ? pffFile.name.replace(/\.pff$/i, '') : 'Uploaded Application';

        // Show preview
        this.$.uploadZone.style.display = 'none';
        this.$.uploadPreview.style.display = 'block';
        this.$.uploadAppName.textContent = appName;
        
        this.$.uploadFileList.innerHTML = csproFiles.map(f => `
            <div class="upload-file-item">
                <span class="upload-file-icon">${this._getFileIcon(f.name)}</span>
                <span class="upload-file-name">${f.relativePath || f.name}</span>
                <span class="upload-file-size">${this._formatFileSize(f.size)}</span>
            </div>
        `).join('');
    }

    _getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        switch (ext) {
            case 'pff': return '';
            case 'pen': return '';
            case 'dcf': return '';
            case 'fmf': return '';
            case 'ent': return '';
            case 'qsf': return '';
            case 'dat': case 'csdb': return '';
            default: return '';
        }
    }

    _formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    async _uploadAndLoadApp() {
        if (!this._pendingUploadFiles || this._pendingUploadFiles.length === 0) return;

        const pffFile = this._pendingUploadFiles.find(f => f.name.toLowerCase().endsWith('.pff'));
        const appName = pffFile ? pffFile.name.replace(/\.pff$/i, '') : 'UploadedApp';

        this.$.btnUploadApp.textContent = 'Uploading...';
        this.$.btnUploadApp.disabled = true;

        try {
            const formData = new FormData();
            formData.append('folderName', appName);
            
            for (const file of this._pendingUploadFiles) {
                formData.append('files', file, file.relativePath || file.name);
            }

            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();
            
            if (!result.success) {
                throw new Error(result.error || 'Upload failed');
            }

            // Close loader and load the app
            this._hideAppLoader();
            await this._loadAppFromServer(appName);

        } catch (error) {
            console.error('Upload error:', error);
            alert('Failed to upload application: ' + error.message);
        } finally {
            this.$.btnUploadApp.textContent = 'Save & Load Application';
            this.$.btnUploadApp.disabled = false;
        }
    }

    async _loadAppFromServer(appName) {
        this._hideAppLoader();
        this._showLoading(`Loading ${appName}...`);

        try {
            const response = await fetch(`/api/applications/${encodeURIComponent(appName)}/files`);
            if (!response.ok) throw new Error('Failed to load application files');

            const files = await response.json();
            
            // Find PFF file
            const pffFileName = Object.keys(files).find(f => f.toLowerCase().endsWith('.pff'));
            if (!pffFileName) throw new Error('No PFF file found in application');

            await this.loadApplicationFromFiles(files, pffFileName);
        } catch (error) {
            console.error('Error loading app from server:', error);
            this._hideLoading();
            alert('Failed to load application: ' + error.message);
        }
    }

    async _loadAppFromAssets(appName, appPath = '', pffFile = '') {
        this._hideAppLoader();
        this._showLoading(`Loading ${appName}...`);

        try {
            // Ensure engine is initialized
            if (!await this.initEngine()) {
                throw new Error('Failed to initialize engine');
            }
            
            // Build the PFF path
            const pffPath = appPath ? `${appPath}/${pffFile}` : `/Assets/examples/${appName}/${pffFile || appName + '.pff'}`;
            console.log('[MFC] Loading embedded application from:', pffPath);
            
            // Server-side mode: use REST API to load embedded asset
            if (this._useServerSide) {
                console.log('[MFC] Loading embedded asset via server API');
                
                // Tell server to load the embedded asset by path
                const loadResult = await this.engine.loadEmbeddedAsset(pffPath);
                if (!loadResult) {
                    throw new Error('Failed to load embedded application on server');
                }
                
                // Start entry session
                const startResult = await this.engine.start('add');
                if (!startResult) {
                    throw new Error('Failed to start session on server');
                }
                
                // Get form data from server
                const formData = await this.engine.getFormData();
                console.log('[MFC] Server formData:', formData);
                
                let forms = [];
                if (formData && formData.success && formData.formFiles) {
                    const formFiles = formData.formFiles;
                    if (formFiles.length > 0) {
                        forms = formFiles[0].forms || [];
                        // Capture data entry orientation from form file
                        this.isPathOn = formFiles[0].pathOn !== false;
                        console.log('[MFC] pathOn from server:', this.isPathOn);
                    }
                }
                
                this.currentApp = {
                    name: formData?.applicationName || appName,
                    dictionaries: [],
                    forms: forms,
                    pathOn: this.isPathOn
                };
                
                this._hideLoading();
                
                if (forms && forms.length > 0) {
                    this._renderFormTabs();
                    await this.addCase();
                } else {
                    this._renderApplication();
                }
                
                this.dispatchEvent(new CustomEvent('applicationLoaded', {
                    detail: { name: this.currentApp.name }
                }));
                
                return;
            }
            
            // Client-side mode: load directly from WASM FS
            let initResult = this.engine.initApplication(pffPath);
            if (initResult && typeof initResult.then === 'function') {
                initResult = await initResult;
            }
            if (!initResult) {
                throw new Error('Failed to initialize application');
            }

            let startResult = this.engine.start();
            if (startResult && typeof startResult.then === 'function') {
                startResult = await startResult;
            }
            if (!startResult) {
                throw new Error('Failed to start session');
            }

            // Get forms from the engine using getFormData
            let forms = [];
            let formData = this.engine.getFormData();
            if (formData && typeof formData.then === 'function') {
                formData = await formData;
            }
            console.log('getFormData result:', formData);
            if (formData && formData.success && formData.formFiles) {
                const formFiles = formData.formFiles;
                if (formFiles.length > 0) {
                    forms = formFiles[0].forms || [];
                    // Capture data entry orientation (pathOn) from form file
                    // pathOn = true means SystemControlled (engine controls path)
                    // pathOn = false means OperatorControlled (free movement)
                    this.isPathOn = formFiles[0].pathOn !== false;
                    console.log(`Loaded ${forms.length} forms from engine, pathOn=${this.isPathOn}`);
                }
            }

            this.currentApp = {
                name: formData?.applicationName || appName,
                dictionaries: [],
                forms: forms,
                pathOn: this.isPathOn
            };

            this._hideLoading();
            
            // Render application and auto-start data entry
            if (forms && forms.length > 0) {
                // Render form tabs
                this._renderFormTabs();
                // Render first form and start entry
                await this.addCase();
            } else {
                this._renderApplication();
            }
            
            this.dispatchEvent(new CustomEvent('applicationLoaded', {
                detail: { name: this.currentApp.name }
            }));
            
        } catch (error) {
            console.error('Error loading app from assets:', error);
            this._hideLoading();
            alert('Failed to load application: ' + error.message);
        }
    }

    async _syncFromCSWeb(dictName, serverUrl) {
        this._hideAppLoader();
        alert(`CSWeb sync for "${dictName}" is not yet implemented.\nServer: ${serverUrl}`);
    }

    _closeApplication() {
        this.currentApp = null;
        this.currentForm = null;
        this.currentField = null;
        this.$.formTitle.textContent = 'No Application Loaded';
        this.$.formContainer.innerHTML = `
            <div class="welcome-message" id="welcomeMessage">
                <h2> CSEntry Web</h2>
                <p>Load a CSPro application to begin data entry.</p>
                <button class="btn btn-primary" id="btnLoadApp">Load Application</button>
            </div>
        `;
        this.$.treeContent.innerHTML = '';
        this.$.formTabs.innerHTML = '';
        
        // Re-bind load button
        this.shadowRoot.querySelector('#btnLoadApp')?.addEventListener('click', () => this._showAppLoader());
    }

    _handleKeyDown(e) {
        // Field input handles its own keys
        if (e.target.classList.contains('form-field-input')) return;

        if (e.ctrlKey) {
            switch (e.key.toLowerCase()) {
                case 'n': e.preventDefault(); this.addCase(); break;
                case 's': e.preventDefault(); this.saveCase(); break;
                case 'g': e.preventDefault(); this._showGoToDialog(); break;
            }
        } else {
            switch (e.key) {
                case 'Enter': this.nextField(); break;
                case 'PageDown': this._pageDown(); break;
                case 'PageUp': this._pageUp(); break;
                case '/': this.endGroup(); break;
            }
        }
    }

    // ========================================================================
    // Public API
    // ========================================================================

    /**
     * Check if browser supports JSPI (JavaScript Promise Integration)
     * Required for client-side WASM execution with async operations
     */
    _checkBrowserJSPISupport() {
        try {
            // JSPI requires WebAssembly.Suspending and WebAssembly.promising
            return typeof WebAssembly.Suspending === 'function' && 
                   typeof WebAssembly.promising === 'function';
        } catch (e) {
            return false;
        }
    }

    /**
     * Check if server-side WASM execution is available
     */
    async _checkServerAvailability() {
        try {
            const response = await fetch('/api/cspro/health');
            const data = await response.json();
            return data.wasmInitialized === true;
        } catch (e) {
            return false;
        }
    }

    /**
     * Initialize the WASM engine
     * Automatically chooses between:
     * 1. Server-side WASM via REST API (preferred for compatibility)
     * 2. Client-side WASM (if browser supports JSPI and server unavailable)
     */
    async initEngine() {
        if (this.engine) return true;
        
        // ALWAYS check server-side availability FIRST
        // This ensures Safari and non-JSPI browsers work via REST API
        console.log('[MFC] Checking server-side WASM availability...');
        const serverAvailable = await this._checkServerAvailability();
        
        if (serverAvailable) {
            // Use server-side WASM via REST API (works in ALL browsers)
            console.log('[MFC] Using server-side WASM execution via REST API');
            this._useServerSide = true;
            this._serverSessionId = null;
            
            // Create a proxy engine that calls the REST API
            this.engine = this._createServerSideEngineProxy();
            console.log('[MFC] CSProEngine initialized (server-side via REST API)');
            return true;
        }
        
        // Server not available - try client-side WASM if browser supports JSPI
        const browserHasJSPI = this._checkBrowserJSPISupport();
        console.log('[MFC] Browser JSPI support:', browserHasJSPI);
        
        if (browserHasJSPI) {
            try {
                console.log('[MFC] Attempting client-side WASM with JSPI...');
                const { default: createCSProModule } = await import('./CSPro.js');
                const module = await createCSProModule();
                this._wasmModule = module;
                window.Module = module;
                this.engine = new module.CSProEngine();
                this._useServerSide = false;
                console.log('[MFC] CSProEngine initialized (client-side WASM with JSPI)');
                return true;
            } catch (error) {
                console.error('[MFC] Client-side WASM failed:', error.message);
            }
        }
        
        // Neither server-side nor client-side available
        const errorMsg = 'CSPro WASM not available.\n\n' +
            'Options:\n' +
            '1. Start the server with JSPI: node --experimental-wasm-jspi server-api.js\n' +
            '2. Use Chrome/Edge with JSPI flag: --enable-features=WebAssemblyJSPI';
        console.error('[MFC]', errorMsg);
        throw new Error(errorMsg);
    }

    /**
     * Create a proxy engine that forwards calls to the server-side REST API
     * This allows non-JSPI browsers (Safari) to use CSPro via HTTP
     */
    _createServerSideEngineProxy() {
        const self = this;
        
        return {
            // Session management
            async _ensureSession() {
                if (!self._serverSessionId) {
                    const response = await fetch('/api/cspro/session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await response.json();
                    if (data.success) {
                        self._serverSessionId = data.sessionId;
                    } else {
                        throw new Error('Failed to create server session');
                    }
                }
                return self._serverSessionId;
            },
            
            // Initialize application
            async initApplication(pffPath) {
                await this._ensureSession();
                // Note: For server-side, we need to send file contents
                // This is handled in loadApplicationFromContent
                return true;
            },
            
            // Load embedded asset from server's WASM FS
            async loadEmbeddedAsset(pffPath) {
                await this._ensureSession();
                
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/load-embedded`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pffPath: pffPath })
                });
                
                const data = await response.json();
                return data.success;
            },
            
            // Load application with files (called from loadApplicationFromContent)
            async loadApplicationWithFiles(pffContent, files) {
                await this._ensureSession();
                
                // Prepare files for transmission
                const processedFiles = {};
                for (const [filename, content] of Object.entries(files || {})) {
                    if (content instanceof Uint8Array) {
                        processedFiles[filename] = {
                            type: 'binary',
                            data: btoa(String.fromCharCode(...content))
                        };
                    } else if (content && content.type === 'binary') {
                        processedFiles[filename] = content;
                    } else {
                        processedFiles[filename] = content;
                    }
                }
                
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pffContent: pffContent,
                        applicationFiles: processedFiles
                    })
                });
                
                const data = await response.json();
                return data.success;
            },
            
            // Start entry session
            async start(mode) {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: mode || 'add' })
                });
                const data = await response.json();
                return data.success;
            },
            
            // Get form structure (application form definitions)
            async getFormData() {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/form-data`);
                const data = await response.json();
                return data;
            },
            
            // Get current page state
            async getCurrentPage() {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/page`);
                const data = await response.json();
                return data.success ? data.page : null;
            },
            
            // Advance field with value (returns bool for compatibility)
            async advanceField(value) {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/advance`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ value: value })
                });
                const data = await response.json();
                return data.success;
            },
            
            // Advance field with value and return full page data (like WASM Embind)
            // This is what _advanceWithValue expects
            async setFieldValueAndAdvance(value) {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/advance`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ value: value !== undefined ? String(value) : '' })
                });
                const data = await response.json();
                console.log('[ServerProxy] setFieldValueAndAdvance response:', data);
                
                // Check for dialogs that were shown server-side
                // Display them on the client (informational - they were auto-acknowledged)
                if (data.dialogs && data.dialogs.length > 0) {
                    console.log('[ServerProxy] Server showed dialogs:', data.dialogs);
                    for (const dialog of data.dialogs) {
                        // Show each dialog to the user
                        await self._showServerDialog(dialog);
                    }
                }
                
                // Return the page data in same format as WASM Embind CSProEngine.setFieldValueAndAdvance
                if (data.success && data.page) {
                    return data.page;
                }
                return null;
            },
            
            // Go to previous field
            async previousField() {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/previous`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                return data.success;
            },
            
            // Get question text
            async getQuestionText(fieldName) {
                const url = new URL(`/api/cspro/session/${self._serverSessionId}/question`, window.location.origin);
                if (fieldName) url.searchParams.set('field', fieldName);
                const response = await fetch(url);
                const data = await response.json();
                // Return object with questionTextHtml property (from WASM getQuestionText)
                return data.success ? { 
                    questionTextHtml: data.questionTextHtml, 
                    questionTextUrl: data.questionTextUrl,
                    fieldName: data.fieldName
                } : null;
            },
            
            // Get responses/value set
            async getResponses(fieldName) {
                const url = new URL(`/api/cspro/session/${self._serverSessionId}/responses`, window.location.origin);
                if (fieldName) url.searchParams.set('field', fieldName);
                const response = await fetch(url);
                const data = await response.json();
                return data.success ? data.responses : [];
            },
            
            // End roster
            async endRoster() {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/end-roster`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                return data.success;
            },
            
            // End group
            async endGroup() {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/end-group`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                return data.success;
            },
            
            // Stop entry
            async stop(save) {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/stop`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ save: save !== false })
                });
                const data = await response.json();
                return data.success;
            },
            
            // Partial save - saves case in current state without completing entry
            async partialSave() {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/partial-save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                console.log('[ServerProxy] partialSave response:', data);
                return data.success;
            },
            
            // Check if session is active
            isSessionActive() {
                return self._serverSessionId !== null;
            },
            
            // OnStop - triggers CSPro stop (save case)
            async onStop() {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/stop`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ save: true })
                });
                const data = await response.json();
                console.log('[ServerProxy] onStop response:', data);
                return data.success;
            },
            
            // Execute Action Invoker
            async executeAction(actionCode, args, accessToken) {
                const response = await fetch(`/api/cspro/session/${self._serverSessionId}/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: actionCode, arguments: args, accessToken })
                });
                const data = await response.json();
                return data.success ? data.result : null;
            },
            
            // List embedded applications from server's WASM filesystem
            listEmbeddedApplications() {
                // This is synchronous but fetches from server
                // We use a synchronous XMLHttpRequest for compatibility with the caller
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/api/cspro/assets', false); // Synchronous
                xhr.send();
                
                if (xhr.status === 200) {
                    try {
                        return JSON.parse(xhr.responseText);
                    } catch (e) {
                        console.error('[ServerProxy] Failed to parse assets response:', e);
                        return { applications: [] };
                    }
                }
                return { applications: [] };
            },
            
            // Cleanup
            async destroy() {
                if (self._serverSessionId) {
                    await fetch(`/api/cspro/session/${self._serverSessionId}`, {
                        method: 'DELETE'
                    });
                    self._serverSessionId = null;
                }
            }
        };
    }

    /**
     * Load a CSPro application from PFF URL
     */
    async loadApplication(url) {
        this._showLoading('Loading application...');
        
        try {
            // Initialize engine if needed
            if (!await this.initEngine()) {
                throw new Error('Failed to initialize CSEntry engine');
            }

            // Fetch PFF file
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const pffContent = await response.text();
            
            // Load application via WASM engine (CSProEngine uses initApplication + start)
            const initResult = this.engine.initApplication(url);
            if (!initResult) {
                throw new Error('Failed to initialize application');
            }

            // Start the engine session
            if (!this.engine.start()) {
                throw new Error('Failed to start data entry session');
            }

            // Get application info from engine via getFormData
            const formData = this.engine.getFormData();
            
            // Capture data entry orientation from form file
            if (formData && formData.formFiles && formData.formFiles.length > 0) {
                this.isPathOn = formData.formFiles[0].pathOn !== false;
                console.log('[MFC] WASM mode - pathOn:', this.isPathOn);
            }
            
            this.currentApp = {
                name: formData?.applicationName || 'Application',
                dictionaries: [],
                forms: [], // Will be populated from formData
                pathOn: this.isPathOn
            };

            this._renderApplication();
            this._hideLoading();
            
            // Dispatch loaded event
            this.dispatchEvent(new CustomEvent('applicationLoaded', {
                detail: { name: this.currentApp.name }
            }));
            
        } catch (error) {
            this._hideLoading();
            this._showError('Failed to load application: ' + error.message);
        }
    }

    /**
     * Load application from file content (for web file picker)
     */
    async loadApplicationFromContent(pffContent, files = null) {
        this._showLoading('Loading application...');
        
        try {
            if (!await this.initEngine()) {
                throw new Error('Failed to initialize CSEntry engine');
            }

            // Server-side mode: use REST API
            if (this._useServerSide) {
                console.log('[MFC] Loading application via server-side REST API');
                
                // Load application with files via server API
                const loadResult = await this.engine.loadApplicationWithFiles(pffContent, files);
                if (!loadResult) {
                    throw new Error('Failed to load application on server');
                }
                
                // Start entry session
                const startResult = await this.engine.start('add');
                if (!startResult) {
                    throw new Error('Failed to start session on server');
                }
                
                // Get form data from server
                const formData = await this.engine.getFormData();
                console.log('[MFC] Server formData:', formData);
                
                // Capture data entry orientation from form file
                if (formData && formData.formFiles && formData.formFiles.length > 0) {
                    this.isPathOn = formData.formFiles[0].pathOn !== false;
                    console.log('[MFC] Server mode - pathOn:', this.isPathOn);
                }
                
                // Setup application state
                this.currentApp = {
                    name: formData?.applicationName || 'Application',
                    dictionaries: [],
                    forms: [],
                    pathOn: this.isPathOn
                };
                
                this._renderApplication();
                this._hideLoading();
                
                // Dispatch loaded event
                this.dispatchEvent(new CustomEvent('applicationLoaded', {
                    detail: { name: this.currentApp.name }
                }));
                
                return;
            }

            // Client-side mode: use Emscripten FS
            const FS = this._wasmModule?.FS;
            if (!FS) {
                throw new Error('Emscripten filesystem not available');
            }

            // Create a temporary directory for this application
            const appDir = '/tmp/app_' + Date.now();
            try {
                FS.mkdir(appDir);
            } catch (e) {
                // Directory may already exist
            }

            let pffPath = '';

            // If files object is provided, write them to the virtual filesystem
            if (files && typeof files === 'object') {
                for (const [filename, content] of Object.entries(files)) {
                    const filePath = `${appDir}/${filename}`;
                    
                    // Create subdirectories if needed
                    const dir = filePath.substring(0, filePath.lastIndexOf('/'));
                    if (dir && dir !== appDir) {
                        try {
                            FS.mkdirTree(dir);
                        } catch (e) { /* may already exist */ }
                    }
                    
                    try {
                        if (typeof content === 'string') {
                            FS.writeFile(filePath, content);
                        } else if (content && content.type === 'binary' && content.data) {
                            // Binary file - decode base64
                            const binary = atob(content.data);
                            const bytes = new Uint8Array(binary.length);
                            for (let i = 0; i < binary.length; i++) {
                                bytes[i] = binary.charCodeAt(i);
                            }
                            FS.writeFile(filePath, bytes);
                        }
                        
                        // Track the PFF file path
                        if (filename.toLowerCase().endsWith('.pff')) {
                            pffPath = filePath;
                        }
                    } catch (e) {
                        console.warn('Failed to write file:', filename, e);
                    }
                }
            }

            // If pffContent is a path (starts with /), use it directly
            // Otherwise use the PFF we wrote to the temp directory
            const initPath = pffPath || pffContent;
            console.log('[MFC] Initializing application from:', initPath);

            // Load via engine (CSProEngine uses initApplication + start)
            // These are Asyncify-wrapped and return Promises
            let initResult = this.engine.initApplication(initPath);
            if (initResult && typeof initResult.then === 'function') {
                initResult = await initResult;
            }
            if (!initResult) {
                throw new Error('Failed to initialize application');
            }

            let startResult = this.engine.start();
            if (startResult && typeof startResult.then === 'function') {
                startResult = await startResult;
            }
            if (!startResult) {
                throw new Error('Failed to start session');
            }

            // Get forms from the engine using getFormData
            let forms = [];
            let formData = this.engine.getFormData();
            if (formData && typeof formData.then === 'function') {
                formData = await formData;
            }
            console.log('getFormData result:', formData);
            if (formData && formData.success && formData.formFiles) {
                // Extract forms from first form file
                const formFiles = formData.formFiles;
                console.log('Form files count:', formFiles.length);
                if (formFiles.length > 0) {
                    forms = formFiles[0].forms || [];
                    // Capture data entry orientation (pathOn) from form file
                    // pathOn = true means SystemControlled (engine controls path)
                    // pathOn = false means OperatorControlled (free movement)
                    this.isPathOn = formFiles[0].pathOn !== false;
                    console.log(`Loaded ${forms.length} forms from engine, pathOn=${this.isPathOn}`);
                    if (forms.length > 0) {
                        console.log('First form:', forms[0]);
                        console.log('First form fields:', forms[0].fields);
                        console.log('First form texts:', forms[0].texts);
                        console.log('First form rosters:', forms[0].rosters);
                    }
                }
            } else {
                console.log('getFormData failed or no formFiles');
            }

            this.currentApp = {
                name: formData?.applicationName || 'Application',
                dictionaries: [],
                forms: forms,
                pathOn: this.isPathOn
            };

            this._renderApplication();
            this._hideLoading();
            
            this.dispatchEvent(new CustomEvent('applicationLoaded', {
                detail: { name: this.currentApp.name }
            }));

        } catch (error) {
            this._hideLoading();
            this._showError('Failed to load application: ' + error.message);
        }
    }

    /**
     * Load application from files object (from server API)
     * @param {Object} files - Object where keys are filenames and values are content (string or {type:'binary', data:base64})
     * @param {string} pffFileName - Name of the PFF file to load
     */
    async loadApplicationFromFiles(files, pffFileName) {
        console.log('[MFC] loadApplicationFromFiles:', pffFileName, 'files:', Object.keys(files));
        
        // Get PFF content
        let pffContent = files[pffFileName];
        if (typeof pffContent !== 'string') {
            if (pffContent && pffContent.type === 'binary' && pffContent.data) {
                pffContent = atob(pffContent.data);
            } else {
                throw new Error('Invalid PFF file content');
            }
        }
        
        // Use the existing loadApplicationFromContent method
        await this.loadApplicationFromContent(pffContent, files);
    }

    /**
     * Add a new case
     */
    async addCase() {
        if (!this.engine) {
            console.warn('[MFC] addCase: No engine available');
            return;
        }
        
        // Render the first form if we have forms
        if (this.currentApp && this.currentApp.forms && this.currentApp.forms.length > 0) {
            this._renderForm(this.currentApp.forms[0]);
        }

        // Debug CAPI configuration
        if (this.engine && typeof this.engine.getCapiDebugInfo === 'function') {
            try {
                const capiDebug = this.engine.getCapiDebugInfo();
                console.log('[MFC] CAPI Debug Info:', capiDebug);
                if (capiDebug) {
                    console.log('[MFC] useQuestionText:', capiDebug.useQuestionText);
                    console.log('[MFC] questionTextFilename:', capiDebug.questionTextFilename);
                    console.log('[MFC] questMgrExists:', capiDebug.questMgrExists);
                    console.log('[MFC] numLanguages:', capiDebug.numLanguages);
                    console.log('[MFC] numQuestions:', capiDebug.numQuestions);
                    if (capiDebug.questionNames) {
                        console.log('[MFC] Question names:', capiDebug.questionNames);
                    }
                }
            } catch (e) {
                console.warn('[MFC] Could not get CAPI debug info:', e);
            }
        }

        // Get current page from engine - this gives us the current field state
        let pageResult = this.engine.getCurrentPage();
        if (pageResult && typeof pageResult.then === 'function') {
            pageResult = await pageResult;
        }
        
        console.log('[MFC] getCurrentPage result:', pageResult);
        
        // Store for QSF access
        this._currentPageResult = pageResult;
        
        if (pageResult && pageResult.fields && pageResult.fields.length > 0) {
            const firstField = pageResult.fields[0];
            console.log('[MFC] First field from engine:', firstField.name, 
                       'indexes:', firstField.indexes,
                       'blockQuestionTextUrl:', pageResult.blockQuestionTextUrl);
            
            // Find the field element - consider indexes for roster fields
            let fieldElement = null;
            if (firstField.indexes && firstField.indexes[0] > 0) {
                // Roster field - find with row index (1-based from engine, 0-based in DOM)
                const rowIndex = firstField.indexes[0] - 1;
                // Try input directly first
                let selector = `input[data-field-name="${firstField.name}"][data-row-index="${rowIndex}"]`;
                fieldElement = this.$.formContainer.querySelector(selector);
                // Also try container elements (for tickmark containers)
                if (!fieldElement) {
                    selector = `.roster-field-container[data-field-name="${firstField.name}"][data-row-index="${rowIndex}"]`;
                    fieldElement = this.$.formContainer.querySelector(selector);
                }
                console.log('[MFC] Looking for roster field:', firstField.name, 'row:', rowIndex, 'found:', fieldElement);
            }
            
            if (!fieldElement) {
                // Standalone field or fallback - look for any element with the field name
                fieldElement = this.$.formContainer.querySelector(`[data-field-name="${firstField.name}"]`);
            }
            
            if (fieldElement) {
                // For containers, find the input inside
                const inputEl = fieldElement.querySelector('input, select') || fieldElement;
                if (inputEl.focus) {
                    setTimeout(() => {
                        inputEl.focus();
                        if (inputEl.select) inputEl.select();
                        inputEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 10);
                }
            } else {
                console.warn('[MFC] Could not find element for first field:', firstField.name);
            }
            
            // Update status with occurrence info and path mode
            const occStr = (firstField.indexes && firstField.indexes[0] > 0) ? 
                `[${firstField.indexes[0]}]` : '';
            const pathMode = this.isPathOn ? 'System Path' : 'Free Movement';
            this._updateStatus(firstField.name + occStr, '', `Add Mode | ${pathMode}`);
            
            // Show CAPI if available - pass pageResult for block-level QSF
            this.currentField = firstField;
            await this._showCAPI(firstField, pageResult);
            
            // Update roster values from engine
            if (this._rosters) {
                for (const rosterName in this._rosters) {
                    this._updateRosterFromEngine(rosterName);
                }
            }
        }
        
        this._buildCaseTree();
        
        this.dispatchEvent(new CustomEvent('caseStarted', { detail: { isNew: true } }));
    }

    /**
     * Save current case
     */
    async saveCase() {
        if (!this.engine) {
            this._showError('No engine available');
            return;
        }
        
        try {
            // Use stop(true) for server proxy or onStop() for WASM
            let saved = false;
            if (typeof this.engine.stop === 'function') {
                saved = await this.engine.stop(true);
            } else if (typeof this.engine.onStop === 'function') {
                await this.engine.onStop();
                saved = true;
            }
            
            if (saved) {
                this.dispatchEvent(new CustomEvent('caseSaved'));
                this._showMessage('Case saved successfully');
            } else {
                this._showError('Failed to save case');
            }
        } catch (e) {
            console.error('[MFC] saveCase error:', e);
            this._showError('Save error: ' + e.message);
        }
    }

    /**
     * Partial save current case
     * Saves the case in its current state without completing entry
     */
    async partialSave() {
        console.log('[MFC] partialSave called');
        if (!this.engine) {
            this._showError('No engine available');
            return;
        }
        
        try {
            // Check if engine has partialSave method
            if (typeof this.engine.partialSave === 'function') {
                const result = await this.engine.partialSave();
                console.log('[MFC] partialSave result:', result);
                if (result) {
                    this.dispatchEvent(new CustomEvent('casePartialSaved'));
                    this._showMessage('Partial save successful');
                } else {
                    this._showError('Partial save failed');
                }
            } else {
                console.warn('[MFC] partialSave not available on engine');
                this._showMessage('Partial save not available');
            }
        } catch (e) {
            console.error('[MFC] partialSave error:', e);
            this._showError('Partial save error: ' + e.message);
        }
    }

    /**
     * Delete current case
     */
    async deleteCase() {
        const confirmed = await this._confirm('Delete Case', 'Are you sure?');
        if (confirmed) {
            // Would call engine.deleteCase() when implemented
            this.addCase();
            this.dispatchEvent(new CustomEvent('caseDeleted'));
        }
    }

    /**
     * Navigate to next field (CSEntry-style path-controlled navigation)
     */
    nextField() {
        this._advanceToNextField();
    }
    
    /**
     * Advance to next field in navigation order
     * This is the core navigation method that mimics CSEntry MFC behavior
     */
    _advanceToNextField() {
        if (this.navigationFields.length === 0) {
            console.warn('No navigation fields available');
            return;
        }
        
        // Save current field value
        const currentInput = this._getCurrentFieldInput();
        if (currentInput) {
            const currentNav = this.navigationFields[this.currentNavIndex];
            if (currentNav) {
                currentNav.value = currentInput.value;
                currentInput.classList.add('visited');
                this._updateTreeValue(currentNav.name, currentInput.value);
            }
        }
        
        // Move to next field
        const nextIndex = this.currentNavIndex + 1;
        if (nextIndex >= this.navigationFields.length) {
            // End of form/case
            this._handleEndOfCase();
            return;
        }
        
        this.currentNavIndex = nextIndex;
        this._focusNavigationField(nextIndex);
    }
    
    /**
     * Advance to next field, sending value to native engine for logic execution
     * This triggers CSPro logic (proc, postproc, errmsg, etc.)
     */
    async _advanceWithValue(value) {
        console.log('[MFC] _advanceWithValue called, value:', value, 'engine:', !!this.engine);
        // If native engine available, use it for logic execution
        if (this.engine && typeof this.engine.setFieldValueAndAdvance === 'function') {
            try {
                console.log('[MFC] Calling setFieldValueAndAdvance with value:', value);
                // Mark WASM as busy to prevent concurrent calls
                this._wasmBusy = true;
                // Await the result - WASM with Asyncify returns a Promise
                let result = this.engine.setFieldValueAndAdvance(value);
                // Handle Promise if returned (Asyncify)
                if (result && typeof result.then === 'function') {
                    console.log('[MFC] setFieldValueAndAdvance returned Promise, awaiting...');
                    result = await result;
                }
                // WASM operation complete
                this._wasmBusy = false;
                console.log('[MFC] setFieldValueAndAdvance result:', JSON.stringify(result));
                
                if (result) {
                    // Store the current page result for QSF access
                    this._currentPageResult = result;
                    
                    // Handle any dialogs that were triggered (errmsg, etc.)
                    // These are returned by the server API when CSPro logic triggers dialogs
                    if (result.dialogs && result.dialogs.length > 0) {
                        console.log('[MFC] Server triggered dialogs:', result.dialogs.length);
                        for (const dialogInfo of result.dialogs) {
                            console.log('[MFC] Showing dialog:', dialogInfo.dialogName);
                            await this._showNativeDialog(dialogInfo.dialogName, dialogInfo.inputData);
                        }
                    }
                    
                    // Process the page result - may need to update UI
                    if (result.fields && result.fields.length > 0) {
                        // Engine returned page with all block fields
                        // Use currentFieldIndex to get the actual current field (default to 0 for backward compatibility)
                        const currentFieldIndex = result.currentFieldIndex ?? 0;
                        const newField = result.fields[currentFieldIndex] || result.fields[0];
                        console.log('[MFC] Engine advanced to field:', newField.name, 
                                    'indexes:', newField.indexes,
                                    'captureType:', newField.captureType,
                                    'responses:', newField.responses?.length || 0,
                                    'currentFieldIndex:', currentFieldIndex,
                                    'blockQuestionTextUrl:', result.blockQuestionTextUrl);
                        
                        // Check if this field needs a selection dialog (like CSEntry MFC)
                        // Fields with captureType DropDown/ComboBox/RadioButton/CheckBox that have responses
                        // can show either the select.html dialog or inline display based on user preference
                        const CT = CSEntryMFCView.CAPTURE_TYPES;
                        const captureType = newField.captureType ?? CT.TextBox;
                        const responses = newField.responses || [];
                        const hasValueSet = responses.length > 0 && (
                            captureType === CT.DropDown || 
                            captureType === CT.ComboBox ||
                            captureType === CT.RadioButton ||
                            captureType === CT.CheckBox
                        );
                        
                        // Check if this is a roster field (has indexes with row > 0)
                        const isRosterField = newField.indexes && newField.indexes.length > 0 && newField.indexes[0] > 0;
                        
                        // Use dialog if:
                        // 1. User preference is 'dialog', OR
                        // 2. It's DropDown or ComboBox capture type (these naturally need popup)
                        // Note: For RadioButton/CheckBox, we respect the user's inline choice even for roster fields
                        const displayMode = this._getCaptureDisplayMode();
                        const isDropDownOrCombo = captureType === CT.DropDown || captureType === CT.ComboBox;
                        const needsSelectDialog = hasValueSet && (displayMode === 'dialog' || isDropDownOrCombo);
                        
                        if (needsSelectDialog) {
                            console.log('[MFC] Field needs select dialog:', newField.name, 'captureType:', captureType, 'responses:', responses.length);
                            // Show select.html dialog and advance with selected value
                            // NOTE: We do NOT call _updateFieldFromEngine here because we don't want
                            // to create inline radio buttons when showing the popup dialog - that would
                            // cause duplicate display of value sets (both inline and in popup)
                            this._showFieldSelectDialog(newField).then(selectedValue => {
                                if (selectedValue !== null && selectedValue !== undefined) {
                                    // Update the current field's display with the selected value BEFORE advancing
                                    this._updateFieldDisplayValue(newField, String(selectedValue));
                                    // Now advance to next field
                                    this._advanceWithValue(String(selectedValue));
                                }
                            });
                            return;
                        }
                        
                        // Update the field element with engine data (captureType, responses)
                        // This is only called for fields that DON'T show a select dialog
                        this._updateFieldFromEngine(newField);
                        
                        // Find and focus the field using name AND indexes for roster fields
                        let fieldElement = null;
                        if (newField.indexes && newField.indexes.length > 0 && newField.indexes[0] > 0) {
                            // Roster field - use row index (1-based from engine, 0-based in DOM)
                            const rowIndex = newField.indexes[0] - 1;
                            
                            // Try multiple selectors in order of specificity
                            // 1. Direct input with field name and row index
                            let selector = `input[data-field-name="${newField.name}"][data-row-index="${rowIndex}"]`;
                            fieldElement = this.$.formContainer.querySelector(selector);
                            
                            // 2. Select element with field name and row index
                            if (!fieldElement) {
                                selector = `select[data-field-name="${newField.name}"][data-row-index="${rowIndex}"]`;
                                fieldElement = this.$.formContainer.querySelector(selector);
                            }
                            
                            // 3. Container element with field name and row index (for tickmarks, radio groups)
                            if (!fieldElement) {
                                selector = `.roster-field-container[data-field-name="${newField.name}"][data-row-index="${rowIndex}"]`;
                                fieldElement = this.$.formContainer.querySelector(selector);
                            }
                            
                            // 4. Any element with matching data attributes
                            if (!fieldElement) {
                                selector = `[data-field-name="${newField.name}"][data-row-index="${rowIndex}"]`;
                                fieldElement = this.$.formContainer.querySelector(selector);
                            }
                            
                            console.log('[MFC] Looking for roster field:', newField.name, 'row:', rowIndex, 'found:', !!fieldElement);
                            
                            // Debug: list all elements with this field name if not found
                            if (!fieldElement) {
                                const allMatches = this.$.formContainer.querySelectorAll(`[data-field-name="${newField.name}"]`);
                                console.log('[MFC] All elements with field name', newField.name, ':', allMatches.length);
                                allMatches.forEach((el, i) => {
                                    console.log(`  [${i}] row-index="${el.dataset.rowIndex}" tagName=${el.tagName}`);
                                });
                            }
                        }
                        
                        if (!fieldElement) {
                            // Standalone field or first occurrence
                            // Try input elements first
                            fieldElement = this.$.formContainer.querySelector(`input[data-field-name="${newField.name}"]`);
                            // Then select elements
                            if (!fieldElement) {
                                fieldElement = this.$.formContainer.querySelector(`select[data-field-name="${newField.name}"]`);
                            }
                            // Then any container
                            if (!fieldElement) {
                                fieldElement = this.$.formContainer.querySelector(`[data-field-name="${newField.name}"]`);
                            }
                            console.log('[MFC] Fallback to first element with name:', newField.name, 'found:', !!fieldElement);
                        }
                        
                        if (fieldElement) {
                            // For roster inputs, fieldElement IS the input
                            // For containers (tickmarks), find the input inside
                            let inputEl = fieldElement;
                            if (fieldElement.tagName !== 'INPUT' && fieldElement.tagName !== 'SELECT') {
                                inputEl = fieldElement.querySelector('input, select') || fieldElement;
                            }
                            
                            console.log('[MFC] Focusing element:', inputEl.tagName, 'fieldName:', inputEl.dataset?.fieldName, 'rowIndex:', inputEl.dataset?.rowIndex);
                            
                            // Use setTimeout to ensure focus happens after any pending DOM updates
                            setTimeout(() => {
                                inputEl.focus();
                                if (inputEl.select) inputEl.select();
                                inputEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }, 10);
                            
                            // Update current field tracking with engine data
                            this.currentField = newField;
                            // Pass page result for block-level QSF
                            await this._showCAPI(newField, result);
                            
                            // Update roster values from engine (like MFC SetGridData)
                            if (newField.indexes && newField.indexes[0] > 0 && this._rosters) {
                                // Find which roster this field belongs to
                                for (const rosterName in this._rosters) {
                                    this._updateRosterFromEngine(rosterName);
                                }
                            }
                        } else {
                            console.warn('[MFC] Could not find field element for:', newField.name, 'indexes:', newField.indexes);
                        }
                        
                        // Update status with occurrence info
                        const occStr = (newField.indexes && newField.indexes[0] > 0) ? 
                            `[${newField.indexes[0]}]` : '';
                        this._updateStatus(newField.name + occStr);
                        return;
                    } else if (result.fieldName) {
                        // Legacy format support
                        const input = this.$.formContainer.querySelector(`[data-field-name="${result.fieldName}"]`);
                        if (input) {
                            input.focus();
                            input.select();
                        }
                        this._updateStatus(result.fieldName);
                        if (this.currentField) {
                            await this._showCAPI(this.currentField);
                        }
                        return;
                    }
                }
            } catch (e) {
                this._wasmBusy = false;
                console.error('[MFC] Error calling setFieldValueAndAdvance:', e);
            }
        } else {
            console.log('[MFC] No native engine setFieldValueAndAdvance available');
        }
        
        // Fallback to simple navigation if no engine or engine call failed
        this._advanceToNextField();
    }
    
    /**
     * Update field element with engine data (captureType, responses, etc.)
     * This replaces a basic text input with the proper capture type control
     * based on engine field data.
     */
    _updateFieldFromEngine(engineField) {
        const existingElement = this.$.formContainer.querySelector(`[data-field-name="${engineField.name}"]`);
        if (!existingElement) {
            console.log('[MFC] No existing element for field:', engineField.name);
            return;
        }
        
        const captureType = engineField.captureType ?? 0;
        const responses = engineField.responses || [];
        
        // Check if we need to replace the element based on capture type
        const needsRadioButtons = captureType === CSEntryMFCView.CAPTURE_TYPES.RadioButton && responses.length > 0;
        const needsCheckboxes = captureType === CSEntryMFCView.CAPTURE_TYPES.CheckBox && responses.length > 0;
        const needsDropdown = captureType === CSEntryMFCView.CAPTURE_TYPES.DropDown && responses.length > 0;
        const needsComboBox = captureType === CSEntryMFCView.CAPTURE_TYPES.ComboBox && responses.length > 0;
        const needsSlider = captureType === CSEntryMFCView.CAPTURE_TYPES.Slider;
        
        // Only replace if the current element type doesn't match needed type
        const currentIsRadio = existingElement.classList.contains('form-field-radio-group');
        const currentIsCheckbox = existingElement.classList.contains('form-field-checkbox-group');
        const currentIsDropdown = existingElement.classList.contains('form-field-dropdown');
        const currentIsComboBox = existingElement.classList.contains('form-field-combobox');
        const currentIsSlider = existingElement.classList.contains('form-field-slider-container');
        
        const needsReplacement = (needsRadioButtons && !currentIsRadio) ||
                                  (needsCheckboxes && !currentIsCheckbox) ||
                                  (needsDropdown && !currentIsDropdown) ||
                                  (needsComboBox && !currentIsComboBox) ||
                                  (needsSlider && !currentIsSlider);
        
        if (!needsReplacement) {
            // Just update the existing element with new data if needed
            console.log('[MFC] Field element type matches, no replacement needed');
            return;
        }
        
        console.log('[MFC] Replacing field element with captureType:', captureType);
        
        // Create new element with engine data
        const fieldIndex = parseInt(existingElement.dataset.fieldIndex) || 0;
        const newElement = this._createFieldElement({
            ...engineField,
            name: engineField.name,
            isNumeric: engineField.isNumeric,
            captureType: captureType,
            responses: responses,
            integerPartLength: engineField.integerPartLength,
            fractionalPartLength: engineField.fractionalPartLength,
            sliderMinValue: engineField.sliderMinValue,
            sliderMaxValue: engineField.sliderMaxValue,
            sliderStep: engineField.sliderStep,
            maxCheckboxSelections: engineField.maxCheckboxSelections
        }, fieldIndex);
        
        // Copy position from existing element
        newElement.style.position = existingElement.style.position;
        newElement.style.left = existingElement.style.left;
        newElement.style.top = existingElement.style.top;
        
        // Set appropriate size
        if (needsRadioButtons || needsCheckboxes) {
            newElement.style.minWidth = '150px';
        } else if (needsSlider) {
            newElement.style.width = existingElement.style.width || '200px';
        } else {
            newElement.style.width = existingElement.style.width;
            newElement.style.height = existingElement.style.height;
        }
        
        // Replace the element
        existingElement.parentNode.replaceChild(newElement, existingElement);
        console.log('[MFC] Field element replaced successfully');
    }
    
    /**
     * Navigate to previous field
     */
    previousField() {
        this._advanceToPreviousField();
    }
    
    /**
     * Advance to previous field in navigation order
     */
    _advanceToPreviousField() {
        if (this.navigationFields.length === 0 || this.currentNavIndex <= 0) {
            return;
        }
        
        // Save current field value
        const currentInput = this._getCurrentFieldInput();
        if (currentInput) {
            const currentNav = this.navigationFields[this.currentNavIndex];
            if (currentNav) {
                currentNav.value = currentInput.value;
            }
        }
        
        // Move to previous field
        this.currentNavIndex--;
        this._focusNavigationField(this.currentNavIndex);
    }

    /**
     * Go to a specific field by name
     */
    goToField(fieldName, occurrence = 1) {
        const navIdx = this.navigationFields.findIndex(nf => 
            nf.name === fieldName && nf.occurrence === occurrence
        );
        
        if (navIdx >= 0) {
            // In path-on mode, can only go to visited or current fields
            if (this.isPathOn && navIdx > this.currentNavIndex) {
                this._showMessage('Cannot skip ahead in path-controlled mode');
                return;
            }
            
            this.currentNavIndex = navIdx;
            this._focusNavigationField(navIdx);
        } else {
            // Try engine fallback
            if (this.engine && this.engine.isSessionActive()) {
                const result = this.engine.goToField(fieldName);
                if (result.success) {
                    this._renderCurrentField(result);
                }
            }
        }
    }
    
    /**
     * Focus a field by navigation index
     */
    _focusNavigationField(navIndex) {
        const navField = this.navigationFields[navIndex];
        if (!navField) return;
        
        // Find the input element
        let input;
        if (navField.rosterName) {
            // Roster field
            input = this.$.formContainer.querySelector(
                `[data-field-name="${navField.name}"][data-row-index="${navField.occurrence - 1}"]`
            );
        } else {
            // Standalone field
            input = this.$.formContainer.querySelector(`[data-field-name="${navField.name}"]`);
        }
        
        if (input) {
            // For containers (radio groups, checkbox groups), find the first focusable child
            let focusTarget = input;
            if (input.classList.contains('roster-field-container') || 
                input.classList.contains('capture-radio') || 
                input.classList.contains('capture-checkbox')) {
                const firstInput = input.querySelector('input, select');
                if (firstInput) {
                    focusTarget = firstInput;
                }
            }
            
            // Focus the element
            if (focusTarget.focus) {
                focusTarget.focus();
            }
            
            // Select text only for text inputs
            if (focusTarget.select && (focusTarget.type === 'text' || focusTarget.tagName === 'INPUT' && !focusTarget.type)) {
                focusTarget.select();
            }
            
            // Scroll into view
            input.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Update current field reference
            this.currentField = navField.field;
            
            // Update status
            const occStr = navField.rosterName ? `[${navField.occurrence}]` : '';
            this._updateStatus(navField.name + occStr);
            
            // Show CAPI if available
            if (navField.field) {
                this._showCAPI(navField.field);
            }
            
            // Highlight in tree
            this._highlightTreeField(navField.name);
        }
    }
    
    /**
     * Get current field input element
     */
    _getCurrentFieldInput() {
        const navField = this.navigationFields[this.currentNavIndex];
        if (!navField) return null;
        
        if (navField.rosterName) {
            return this.$.formContainer.querySelector(
                `[data-field-name="${navField.name}"][data-row-index="${navField.occurrence - 1}"]`
            );
        } else {
            return this.$.formContainer.querySelector(`[data-field-name="${navField.name}"]`);
        }
    }
    
    /**
     * Handle end of case
     */
    _handleEndOfCase() {
        this._showMessage('End of case reached. Save case?');
        this.dispatchEvent(new CustomEvent('endOfCase'));
    }

    /**
     * End current group
     */
    endGroup() {
        this._showMessage('End group');
        this.dispatchEvent(new CustomEvent('groupEnded'));
    }

    // ========================================================================
    // Internal Methods
    // ========================================================================

    /**
     * Render the current field from engine result
     */
    _renderCurrentField(fieldResult) {
        this.currentField = {
            name: fieldResult.fieldName,
            label: fieldResult.fieldLabel,
            type: fieldResult.fieldType,
            length: fieldResult.fieldLength,
            decimals: fieldResult.decimals,
            isProtected: fieldResult.isProtected,
            occurrence: fieldResult.occurrenceNumber,
            maxOccurrences: fieldResult.maxOccurrences,
            questionText: fieldResult.questionText,
            helpText: fieldResult.helpText,
            hasValueSet: fieldResult.hasValueSet,
            valueSet: fieldResult.hasValueSet ? 
                fieldResult.valueSetValues.map((v, i) => ({ 
                    code: v, 
                    label: fieldResult.valueSetLabels[i] 
                })) : []
        };

        // Focus the field input if it exists
        const input = this.$.formContainer.querySelector(`[data-field-name="${this.currentField.name}"]`);
        if (input) {
            input.focus();
            input.select();
            input.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Show CAPI panel
        this._showCAPI(this.currentField);

        // Update tree highlight
        this._highlightTreeField(this.currentField.name);

        // Update status bar
        const occStr = this.currentField.maxOccurrences > 1 ? 
            `Occ ${this.currentField.occurrence}/${this.currentField.maxOccurrences}` : '';
        this._updateStatus(this.currentField.name, occStr);

        this.dispatchEvent(new CustomEvent('fieldChanged', { 
            detail: this.currentField
        }));
    }

    /**
     * Get value from current field input
     * Handles different capture types (TextBox, RadioButton, CheckBox, DropDown, Slider)
     */
    _getCurrentFieldValue() {
        if (!this.currentField) return '';
        const element = this.$.formContainer.querySelector(`[data-field-name="${this.currentField.name}"]`);
        return this._getFieldElementValue(element);
    }

    _parsePFF(content) {
        const pff = {};
        let currentSection = '';
        
        content.split(/\r?\n/).forEach(line => {
            line = line.trim();
            if (!line || line.startsWith(';')) return;
            
            const sectionMatch = line.match(/^\[(.+)\]$/);
            if (sectionMatch) {
                currentSection = sectionMatch[1];
                pff[currentSection] = {};
                return;
            }
            
            const [key, ...valueParts] = line.split('=');
            if (key && currentSection) {
                pff[currentSection][key.trim()] = valueParts.join('=').trim();
            }
        });
        
        return pff;
    }

    _renderApplication() {
        if (!this.currentApp) return;
        
        this.$.formTitle.textContent = this.currentApp.name;
        
        // Render form tabs if we have forms
        if (this.currentApp.forms && this.currentApp.forms.length > 0) {
            this._renderFormTabs();
        }
        
        // Show welcome message with application info
        this.$.formContainer.innerHTML = `
            <div class="welcome-message">
                <h2> ${this.currentApp.name}</h2>
                <p>Application loaded with ${this.currentApp.forms ? this.currentApp.forms.length : 0} form(s). Click "Add Case" to begin data entry.</p>
                <button class="btn btn-primary" id="btnStartEntry">Add New Case</button>
            </div>
        `;
        
        const startBtn = this.$.formContainer.querySelector('#btnStartEntry');
        if (startBtn) {
            startBtn.addEventListener('click', () => this.addCase());
        }
        
        this._buildCaseTree();
    }

    _renderFormTabs() {
        this.$.formTabs.innerHTML = '';
        this.currentApp.forms.forEach((form, i) => {
            const tab = document.createElement('div');
            tab.className = 'form-tab' + (i === 0 ? ' active' : '');
            tab.textContent = form.label || form.name;
            tab.dataset.index = i;
            tab.addEventListener('click', () => this._switchForm(i));
            this.$.formTabs.appendChild(tab);
        });
    }

    _switchForm(index) {
        this.$.formTabs.querySelectorAll('.form-tab').forEach((tab, i) => {
            tab.classList.toggle('active', i === index);
        });
        this._renderForm(this.currentApp.forms[index]);
    }

    _renderForm(form) {
        console.log('_renderForm called with:', form);
        this.currentForm = form;
        this.$.formContainer.innerHTML = '';
        this.$.formContainer.style.width = (form.width || 800) + 'px';
        this.$.formContainer.style.minHeight = (form.height || 600) + 'px';
        this.$.formContainer.style.position = 'relative';
        this.$.formContainer.style.backgroundColor = '#ffffff';
        
        console.log(`Rendering form: ${form.name}, size: ${form.width}x${form.height}`);
        console.log(`Form has ${form.texts?.length || 0} texts, ${form.fields?.length || 0} fields, ${form.rosters?.length || 0} rosters`);
        
        // Render texts (standalone)
        form.texts?.forEach((text, idx) => {
            console.log(`Text ${idx}: "${text.text}" at (${text.x}, ${text.y})`);
            const el = document.createElement('div');
            el.className = 'form-text' + (text.bold ? ' bold' : '') + (text.underline ? ' underline' : '');
            el.style.position = 'absolute';
            el.style.left = text.x + 'px';
            el.style.top = text.y + 'px';
            el.textContent = text.text;
            this.$.formContainer.appendChild(el);
        });
        
        // Render standalone fields (not in rosters)
        form.fields?.forEach((field, i) => {
            console.log(`Field ${i}: ${field.name} at (${field.x}, ${field.y}), label: "${field.label}", captureType: ${field.captureType}`);
            // Label
            if (field.textX || field.textY || field.text || field.label) {
                const label = document.createElement('div');
                label.className = 'form-field-label';
                label.style.position = 'absolute';
                label.style.left = (field.textX || field.x) + 'px';
                label.style.top = (field.textY || field.y) + 'px';
                label.textContent = field.text || field.label || field.name;
                this.$.formContainer.appendChild(label);
            }
            
            // Create field element based on capture type (RadioButton, CheckBox, DropDown, Slider, etc.)
            const fieldElement = this._createFieldElement(field, i);
            fieldElement.style.position = 'absolute';
            fieldElement.style.left = field.x + 'px';
            fieldElement.style.top = field.y + 'px';
            
            // Set size based on capture type
            const captureType = field.captureType ?? 0;
            if (captureType === CSEntryMFCView.CAPTURE_TYPES.RadioButton || 
                captureType === CSEntryMFCView.CAPTURE_TYPES.CheckBox) {
                // Radio buttons and checkboxes size themselves based on content
                fieldElement.style.minWidth = (field.width || 150) + 'px';
            } else if (captureType === CSEntryMFCView.CAPTURE_TYPES.Slider) {
                fieldElement.style.width = (field.width || 200) + 'px';
            } else if (!fieldElement.classList.contains('form-field-tickmark-container')) {
                // Standard inputs get explicit size
                fieldElement.style.width = (field.width || 100) + 'px';
                fieldElement.style.height = (field.height || 20) + 'px';
            }
            
            // Field events - get the actual input element
            let inputElement = fieldElement;
            if (fieldElement.classList.contains('form-field-tickmark-container')) {
                inputElement = fieldElement.querySelector('input');
            } else if (fieldElement.classList.contains('form-field-radio-group') ||
                       fieldElement.classList.contains('form-field-checkbox-group') ||
                       fieldElement.classList.contains('form-field-slider-container')) {
                // For container elements, events are already attached
                inputElement = null;
            }
            
            if (inputElement && inputElement.tagName) {
                inputElement.addEventListener('focus', () => this._onFieldFocus(field, inputElement));
                inputElement.addEventListener('blur', () => this._onFieldBlur(field, inputElement));
                inputElement.addEventListener('keydown', (e) => this._onFieldKeyDown(e, field, inputElement));
                inputElement.addEventListener('input', () => this._onFieldInput(field, inputElement));
            }
            
            this.$.formContainer.appendChild(fieldElement);
        });
        
        // Render rosters/grids as HTML tables - Engine-driven like MFC DEGrid
        form.rosters?.forEach((roster, rIdx) => {
            // Log roster orientation and movement settings
            // orientation: "Horizontal" (rows = occurrences) or "Vertical" (columns = occurrences)
            // freeMovement: boolean (true if operator can move freely within roster)
            // freeMovementMode: 0=Disabled, 1=Horizontal, 2=Vertical
            console.log(`Roster ${rIdx}: ${roster.name} at (${roster.x}, ${roster.y}), columns: ${roster.columns?.length || 0}, orientation: ${roster.orientation}, freeMovement: ${roster.freeMovement}, freeMovementMode: ${roster.freeMovementMode}`);
            
            // Create roster container
            const rosterDiv = document.createElement('div');
            rosterDiv.className = 'form-roster';
            rosterDiv.dataset.rosterName = roster.name;
            // Store orientation settings in data attributes for navigation logic
            rosterDiv.dataset.orientation = roster.orientation || 'Horizontal';
            rosterDiv.dataset.freeMovement = roster.freeMovement ? '1' : '0';
            rosterDiv.dataset.freeMovementMode = roster.freeMovementMode || '0';
            rosterDiv.style.position = 'absolute';
            rosterDiv.style.left = roster.x + 'px';
            rosterDiv.style.top = roster.y + 'px';
            rosterDiv.style.width = (roster.width || 400) + 'px';
            rosterDiv.style.height = (roster.height || 300) + 'px';
            
            // Create table
            const table = document.createElement('table');
            table.className = 'roster-table';
            table.dataset.rosterName = roster.name;
            
            // Create header row
            const thead = document.createElement('thead');
            thead.className = 'roster-header';
            const headerRow = document.createElement('tr');
            
            // Row number column header
            const rowNumTh = document.createElement('th');
            rowNumTh.textContent = '#';
            rowNumTh.style.width = '30px';
            headerRow.appendChild(rowNumTh);
            
            // Column headers
            roster.columns?.forEach((col, cIdx) => {
                const th = document.createElement('th');
                th.textContent = col.heading || `Column ${cIdx + 1}`;
                if (col.width > 0) {
                    th.style.width = col.width + 'px';
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body rows - linked to engine
            const tbody = document.createElement('tbody');
            tbody.className = 'roster-body';
            tbody.dataset.rosterName = roster.name;
            
            const maxOcc = roster.maxOccurrences || 20;
            const visibleRows = Math.min(maxOcc, 10); // Show first 10 rows initially
            
            for (let rowIdx = 0; rowIdx < visibleRows; rowIdx++) {
                const tr = document.createElement('tr');
                tr.dataset.rowIndex = rowIdx;
                tr.dataset.rosterName = roster.name;
                tr.dataset.occurrence = rowIdx + 1; // 1-based for engine
                
                // Row number / stub text
                const rowNumTd = document.createElement('td');
                rowNumTd.className = 'roster-row-number';
                rowNumTd.textContent = roster.stubTexts?.[rowIdx] || (rowIdx + 1).toString();
                tr.appendChild(rowNumTd);
                
                // Column cells with field inputs
                roster.columns?.forEach((col, cIdx) => {
                    const td = document.createElement('td');
                    td.className = 'roster-cell';
                    
                    // Each column can have one or more fields
                    col.fields?.forEach((field, fIdx) => {
                        // Create input element for the field
                        const inputElement = this._createRosterCellInput(field, rowIdx, roster);
                        td.appendChild(inputElement);
                    });
                    
                    // If no fields in column, just leave cell empty
                    if (!col.fields || col.fields.length === 0) {
                        td.innerHTML = '&nbsp;';
                    }
                    
                    tr.appendChild(td);
                });
                
                tbody.appendChild(tr);
            }
            
            table.appendChild(tbody);
            rosterDiv.appendChild(table);
            this.$.formContainer.appendChild(rosterDiv);
            
            // Store roster reference for engine updates
            if (!this._rosters) this._rosters = {};
            this._rosters[roster.name] = { element: rosterDiv, data: roster };
        });
        
        // Build navigation field list for CSEntry-style navigation
        this._buildNavigationFields(form);
        
        // Start at first field
        if (this.navigationFields.length > 0) {
            this.currentNavIndex = 0;
            this._focusNavigationField(0);
        }
    }
    
    /**
     * Create a roster element from roster data
     * This can be used to re-render a roster when display mode changes
     * @param {Object} roster - Roster data object
     * @returns {HTMLElement} - The roster container element
     */
    _createRosterElement(roster) {
        // Create roster container
        const rosterDiv = document.createElement('div');
        rosterDiv.className = 'form-roster';
        rosterDiv.dataset.rosterName = roster.name;
        // Store orientation settings in data attributes for navigation logic
        rosterDiv.dataset.orientation = roster.orientation || 'Horizontal';
        rosterDiv.dataset.freeMovement = roster.freeMovement ? '1' : '0';
        rosterDiv.dataset.freeMovementMode = roster.freeMovementMode || '0';
        rosterDiv.style.position = 'absolute';
        rosterDiv.style.left = roster.x + 'px';
        rosterDiv.style.top = roster.y + 'px';
        rosterDiv.style.width = (roster.width || 400) + 'px';
        rosterDiv.style.height = (roster.height || 300) + 'px';
        
        // Create table
        const table = document.createElement('table');
        table.className = 'roster-table';
        table.dataset.rosterName = roster.name;
        
        // Create header row
        const thead = document.createElement('thead');
        thead.className = 'roster-header';
        const headerRow = document.createElement('tr');
        
        // Row number column header
        const rowNumTh = document.createElement('th');
        rowNumTh.textContent = '#';
        rowNumTh.style.width = '30px';
        headerRow.appendChild(rowNumTh);
        
        // Column headers
        roster.columns?.forEach((col, cIdx) => {
            const th = document.createElement('th');
            th.textContent = col.heading || `Column ${cIdx + 1}`;
            if (col.width > 0) {
                th.style.width = col.width + 'px';
            }
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create body rows - linked to engine
        const tbody = document.createElement('tbody');
        tbody.className = 'roster-body';
        tbody.dataset.rosterName = roster.name;
        
        const maxOcc = roster.maxOccurrences || 20;
        const visibleRows = Math.min(maxOcc, 10); // Show first 10 rows initially
        
        for (let rowIdx = 0; rowIdx < visibleRows; rowIdx++) {
            const tr = document.createElement('tr');
            tr.dataset.rowIndex = rowIdx;
            tr.dataset.rosterName = roster.name;
            tr.dataset.occurrence = rowIdx + 1; // 1-based for engine
            
            // Row number / stub text
            const rowNumTd = document.createElement('td');
            rowNumTd.className = 'roster-row-number';
            rowNumTd.textContent = roster.stubTexts?.[rowIdx] || (rowIdx + 1).toString();
            tr.appendChild(rowNumTd);
            
            // Column cells with field inputs
            roster.columns?.forEach((col, cIdx) => {
                const td = document.createElement('td');
                td.className = 'roster-cell';
                
                // Each column can have one or more fields
                col.fields?.forEach((field, fIdx) => {
                    // Create input element for the field
                    const inputElement = this._createRosterCellInput(field, rowIdx, roster);
                    td.appendChild(inputElement);
                });
                
                // If no fields in column, just leave cell empty
                if (!col.fields || col.fields.length === 0) {
                    td.innerHTML = '&nbsp;';
                }
                
                tr.appendChild(td);
            });
            
            tbody.appendChild(tr);
        }
        
        table.appendChild(tbody);
        rosterDiv.appendChild(table);
        
        // Store roster reference for engine updates
        if (!this._rosters) this._rosters = {};
        this._rosters[roster.name] = { element: rosterDiv, data: roster };
        
        return rosterDiv;
    }
    
    /**
     * Create input element for a roster cell - handles all capture types
     * Matches MFC DEGrid behavior with proper engine linking
     */
    _createRosterCellInput(field, rowIdx, roster) {
        const isNumeric = field.numeric || field.isNumeric;
        const fieldLength = field.length || field.alphaLength || field.integerPartLength || 10;
        const decimalPlaces = field.decimalPlaces || field.fractionalPartLength || 0;
        const occurrence = rowIdx + 1; // 1-based for engine
        const responses = field.responses || [];
        
        // Normalize captureType - handle both string (from getFormData) and int (from getCurrentPage)
        let captureType = field.captureType ?? 0;
        if (typeof captureType === 'string') {
            const CT = CSEntryMFCView.CAPTURE_TYPES;
            const captureTypeMap = {
                'TextBox': CT.TextBox,
                'RadioButton': CT.RadioButton,
                'CheckBox': CT.CheckBox,
                'DropDown': CT.DropDown,
                'ComboBox': CT.ComboBox,
                'Date': CT.Date,
                'NumberPad': CT.NumberPad,
                'Barcode': CT.Barcode,
                'Slider': CT.Slider,
                'ToggleButton': CT.ToggleButton
            };
            captureType = captureTypeMap[captureType] ?? CT.TextBox;
        }
        
        // Create container for the cell
        const container = document.createElement('div');
        container.className = 'roster-field-container';
        container.dataset.fieldName = field.name;
        container.dataset.rosterName = roster.name;
        container.dataset.rowIndex = rowIdx;
        container.dataset.occurrence = occurrence;
        container.dataset.captureType = captureType;
        
        if (field.isProtected || field.isMirror) {
            container.classList.add('protected');
        }
        
        // Handle different capture types
        const CT = CSEntryMFCView.CAPTURE_TYPES;
        
        // Log capture type for debugging
        if (captureType !== CT.TextBox && captureType !== CT.NumberPad) {
            console.log('[MFC] Roster field captureType:', field.name, 'type:', captureType, 'responses:', responses.length);
        }
        
        // Get display mode to determine inline vs dialog behavior
        const displayMode = this._getCaptureDisplayMode();
        const useInlineMode = displayMode === 'inline';
        
        // For roster fields with RadioButton/CheckBox capture types:
        // - When displayMode === 'inline': Show inline radio buttons/checkboxes in cells
        // - When displayMode === 'dialog': Use tick marks + dialog popup
        
        // RadioButton in roster - inline display when user selects inline mode
        if (captureType === CT.RadioButton && responses.length > 0 && useInlineMode) {
            container.classList.add('capture-radio');
            
            // Create selected value display (shown when not active)
            const valueDisplay = document.createElement('div');
            valueDisplay.className = 'selected-value-display';
            valueDisplay.dataset.fieldName = field.name;
            valueDisplay.dataset.rowIndex = rowIdx;
            valueDisplay.textContent = ''; // Will show selected value
            container.appendChild(valueDisplay);
            
            // Create radio group (hidden until active)
            const radioGroup = document.createElement('div');
            radioGroup.className = 'roster-radio-group';
            
            responses.forEach((resp, i) => {
                const label = document.createElement('label');
                label.className = 'roster-radio-option';
                label.title = resp.label || resp.code;
                
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = `${field.name}_${rowIdx}`;
                radio.value = resp.code;
                radio.dataset.fieldName = field.name;
                radio.dataset.rowIndex = rowIdx;
                radio.dataset.occurrence = occurrence;
                
                // Compact: show code only, full label in title
                const span = document.createElement('span');
                span.textContent = resp.code;
                
                label.appendChild(radio);
                label.appendChild(span);
                radioGroup.appendChild(label);
                
                // Event handlers
                radio.addEventListener('change', (e) => {
                    // Update value display
                    valueDisplay.textContent = resp.code;
                    // Deactivate container after selection (hide options)
                    setTimeout(() => {
                        container.classList.remove('active');
                    }, 50);
                    this._onRosterRadioChange(e, field, rowIdx, roster, resp);
                });
                radio.addEventListener('focus', (e) => this._onRosterCellFocus(e, field, rowIdx, roster, radio));
            });
            
            container.appendChild(radioGroup);
            
            // Click on value display or container activates the options
            valueDisplay.addEventListener('click', (e) => {
                e.stopPropagation();
                // Deactivate any other active containers
                this.$.formContainer.querySelectorAll('.roster-field-container.active').forEach(c => {
                    if (c !== container) c.classList.remove('active');
                });
                container.classList.add('active');
                // Focus the first radio or the checked one
                const checkedRadio = radioGroup.querySelector('input:checked') || radioGroup.querySelector('input');
                if (checkedRadio) checkedRadio.focus();
            });
            
            container.addEventListener('click', (e) => {
                if (e.target === container) {
                    this._onRosterCellClick(e, field, rowIdx, roster, container);
                }
            });
            return container;
        }
        
        // CheckBox in roster - inline display when user selects inline mode
        if (captureType === CT.CheckBox && responses.length > 0 && useInlineMode) {
            container.classList.add('capture-checkbox');
            
            // Create selected value display (shown when not active)
            const valueDisplay = document.createElement('div');
            valueDisplay.className = 'selected-value-display';
            valueDisplay.dataset.fieldName = field.name;
            valueDisplay.dataset.rowIndex = rowIdx;
            valueDisplay.textContent = ''; // Will show selected values
            container.appendChild(valueDisplay);
            
            // Create checkbox group (hidden until active)
            const checkGroup = document.createElement('div');
            checkGroup.className = 'roster-checkbox-group';
            
            responses.forEach((resp, i) => {
                const label = document.createElement('label');
                label.className = 'roster-checkbox-option';
                label.title = resp.label || resp.code;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = resp.code;
                checkbox.dataset.fieldName = field.name;
                checkbox.dataset.rowIndex = rowIdx;
                checkbox.dataset.occurrence = occurrence;
                
                const span = document.createElement('span');
                span.textContent = resp.code;
                
                label.appendChild(checkbox);
                label.appendChild(span);
                checkGroup.appendChild(label);
                
                checkbox.addEventListener('change', (e) => {
                    // Update value display with all checked values
                    const checkedBoxes = checkGroup.querySelectorAll('input:checked');
                    const values = Array.from(checkedBoxes).map(cb => cb.value);
                    valueDisplay.textContent = values.join(',');
                    this._onRosterCheckboxChange(e, field, rowIdx, roster, resp);
                });
                checkbox.addEventListener('focus', (e) => this._onRosterCellFocus(e, field, rowIdx, roster, checkbox));
            });
            
            container.appendChild(checkGroup);
            
            // Click on value display activates the options
            valueDisplay.addEventListener('click', (e) => {
                e.stopPropagation();
                // Deactivate any other active containers
                this.$.formContainer.querySelectorAll('.roster-field-container.active').forEach(c => {
                    if (c !== container) c.classList.remove('active');
                });
                container.classList.add('active');
                // Focus the first checkbox
                const firstCheckbox = checkGroup.querySelector('input');
                if (firstCheckbox) firstCheckbox.focus();
            });
            
            container.addEventListener('click', (e) => {
                if (e.target === container) {
                    this._onRosterCellClick(e, field, rowIdx, roster, container);
                }
            });
            return container;
        }
        
        // DropDown - use select element (selection only, no text input)
        if (captureType === CT.DropDown && responses.length > 0 && useInlineMode) {
            container.classList.add('capture-dropdown');
            const select = document.createElement('select');
            select.className = 'roster-select';
            select.dataset.fieldName = field.name;
            select.dataset.rowIndex = rowIdx;
            select.dataset.occurrence = occurrence;
            
            // Add blank option
            const blankOpt = document.createElement('option');
            blankOpt.value = '';
            blankOpt.textContent = '';
            select.appendChild(blankOpt);
            
            responses.forEach(resp => {
                const opt = document.createElement('option');
                opt.value = resp.code;
                opt.textContent = `${resp.code} - ${resp.label}`;
                select.appendChild(opt);
            });
        
            select.addEventListener('change', (e) => this._onRosterSelectChange(e, field, rowIdx, roster));
            select.addEventListener('focus', (e) => this._onRosterCellFocus(e, field, rowIdx, roster, select));
            select.addEventListener('keydown', (e) => this._onRosterCellKeyDown(e, field, rowIdx, roster, select));
            
            container.appendChild(select);
            return container;
        }
        
        // ComboBox - use text input with datalist (allows both text entry AND selection)
        if (captureType === CT.ComboBox && responses.length > 0 && useInlineMode) {
            container.classList.add('capture-combobox');
            
            // Create text input
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'roster-combobox-input';
            input.dataset.fieldName = field.name;
            input.dataset.rowIndex = rowIdx;
            input.dataset.occurrence = occurrence;
            input.maxLength = fieldLength + (decimalPlaces > 0 ? 1 : 0);
            
            // Create datalist for suggestions
            const datalistId = `datalist_${field.name}_${rowIdx}`;
            const datalist = document.createElement('datalist');
            datalist.id = datalistId;
            
            responses.forEach(resp => {
                const opt = document.createElement('option');
                opt.value = resp.code;
                opt.textContent = resp.label;
                datalist.appendChild(opt);
            });
            
            input.setAttribute('list', datalistId);
            
            // Event handlers
            input.addEventListener('focus', (e) => this._onRosterCellFocus(e, field, rowIdx, roster, input));
            input.addEventListener('blur', (e) => this._onRosterCellBlur(e, field, rowIdx, roster, input));
            input.addEventListener('keydown', (e) => this._onRosterCellKeyDown(e, field, rowIdx, roster, input));
            input.addEventListener('input', (e) => this._onRosterCellInput(e, field, rowIdx, roster, input));
            input.addEventListener('click', (e) => this._onRosterCellClick(e, field, rowIdx, roster, input));
            
            container.appendChild(input);
            container.appendChild(datalist);
            return container;
        }
        
        // Default: TextBox or NumberPad - use text input with tickmarks based on field properties
        // Also used when displayMode is 'dialog' for RadioButton/CheckBox fields (dialog will show on focus)
        const input = document.createElement('input');
        input.type = 'text';
        input.className = isNumeric ? 'roster-cell-input numeric' : 'roster-cell-input';
        input.dataset.fieldName = field.name;
        input.dataset.rosterName = roster.name;
        input.dataset.rowIndex = rowIdx;
        input.dataset.occurrence = occurrence;
        input.dataset.isNumeric = isNumeric ? '1' : '0';
        input.maxLength = fieldLength + (decimalPlaces > 0 ? 1 : 0);
        
        if (field.isProtected || field.isMirror) {
            input.readOnly = true;
        }
        
        // Determine if field should show tick marks (MFC style)
        // Rules based on CSEntry MFC FormView.cpp line 6253:
        // - Numeric fields: ALWAYS show tick marks
        // - Alpha fields: Only show tick marks if NOT using Unicode textbox
        // In practice: Short fields (codes, numeric) get tick marks; long alpha fields (names) don't
        // The useUnicodeTextBox flag indicates alpha fields without tick marks
        const useUnicodeTextBox = field.useUnicodeTextBox || false;
        const shouldShowTickMarks = isNumeric || (!useUnicodeTextBox && fieldLength <= 10);
        
        if (shouldShowTickMarks && fieldLength <= 20) {
            container.classList.add('has-tickmarks');
            const tickmarks = document.createElement('div');
            tickmarks.className = 'roster-tickmarks';
            
            for (let i = 0; i < fieldLength; i++) {
                const tick = document.createElement('span');
                tick.className = 'roster-tick';
                // Mark decimal position for numeric fields
                if (isNumeric && decimalPlaces > 0 && i === fieldLength - decimalPlaces - 1) {
                    tick.classList.add('decimal-point');
                }
                tickmarks.appendChild(tick);
            }
            container.appendChild(tickmarks);
            
            // Update tickmarks display on input - show characters in tick positions
            input.addEventListener('input', () => {
                this._updateTickmarkDisplay(input, tickmarks, fieldLength, decimalPlaces, isNumeric);
            });
        }
        
        container.appendChild(input);
        
        // Field events - ENGINE-DRIVEN like MFC OnCellField_LClicked and OnEditEnter
        input.addEventListener('focus', (e) => this._onRosterCellFocus(e, field, rowIdx, roster, input));
        input.addEventListener('blur', (e) => this._onRosterCellBlur(e, field, rowIdx, roster, input));
        input.addEventListener('keydown', (e) => this._onRosterCellKeyDown(e, field, rowIdx, roster, input));
        input.addEventListener('input', (e) => this._onRosterCellInput(e, field, rowIdx, roster, input));
        
        // Click handler - like MFC OnCellField_LClicked, moves to field via engine
        input.addEventListener('click', (e) => this._onRosterCellClick(e, field, rowIdx, roster, input));
        
        return container;
    }
    
    /**
     * Save roster cell value without advancing to next field
     * This is used for Enter key behavior in rosters
     */
    async _saveRosterCellValue(field, rowIdx, roster, value) {
        if (!this.engine) return;
        
        const occurrence = rowIdx + 1;
        console.log(`[MFC] Saving roster cell: ${field.name}[${occurrence}] = "${value}"`);
        
        try {
            // Call setFieldValue without advancing
            if (typeof this.engine.setFieldValue === 'function') {
                this.engine.setFieldValue(String(value));
            }
        } catch (e) {
            console.error('[MFC] Error saving roster value:', e);
        }
    }
    
    /**
     * Handle radio button change in roster cell
     * In MFC CSEntry, selecting a radio button auto-advances to next field
     */
    async _onRosterRadioChange(e, field, rowIdx, roster, response) {
        const value = response.code;
        console.log(`[MFC] Roster radio change: ${field.name}[${rowIdx + 1}] = ${value}`);
        // Auto-advance like MFC does when radio is clicked
        await this._advanceWithValue(String(value));
    }
    
    /**
     * Handle checkbox change in roster cell
     */
    _onRosterCheckboxChange(e, field, rowIdx, roster, response) {
        // For checkboxes, we need to collect all checked values
        const container = e.target.closest('.roster-field-container');
        const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
        const values = Array.from(checkboxes).map(cb => cb.value);
        console.log(`[MFC] Roster checkbox change: ${field.name}[${rowIdx + 1}] = ${values.join(',')}`);
        // Checkboxes typically don't auto-advance - user clicks Next when done
    }
    
    /**
     * Handle select change in roster cell
     * In MFC CSEntry, selecting from dropdown auto-advances to next field
     */
    async _onRosterSelectChange(e, field, rowIdx, roster) {
        const value = e.target.value;
        if (value) {
            console.log(`[MFC] Roster select change: ${field.name}[${rowIdx + 1}] = ${value}`);
            // Auto-advance like MFC does when selection is made
            await this._advanceWithValue(String(value));
        }
    }
    
    /**
     * Update tickmark display with value characters (MFC style)
     * For numeric: right-aligned
     * For alpha: left-aligned
     */
    _updateTickmarkDisplay(input, tickmarks, length, decimalPlaces, isNumeric = true) {
        const value = input.value.replace(/[.,]/g, ''); // Remove decimal points for positioning
        const ticks = tickmarks.querySelectorAll('.roster-tick');
        
        if (isNumeric) {
            // Right-align numeric values (like MFC)
            const startPos = length - value.length;
            
            ticks.forEach((tick, i) => {
                const charIndex = i - startPos;
                if (charIndex >= 0 && charIndex < value.length) {
                    tick.textContent = value[charIndex];
                    tick.classList.add('filled');
                } else {
                    tick.textContent = '';
                    tick.classList.remove('filled');
                }
            });
        } else {
            // Left-align alpha values
            ticks.forEach((tick, i) => {
                if (i < value.length) {
                    tick.textContent = value[i];
                    tick.classList.add('filled');
                } else {
                    tick.textContent = '';
                    tick.classList.remove('filled');
                }
            });
        }
    }
    
    /**
     * Handle roster cell focus - MFC equivalent of StartEdit
     * Should get current value from engine
     */
    async _onRosterCellFocus(e, field, rowIdx, roster, input) {
        const occurrence = rowIdx + 1;
        
        // Highlight current row (like MFC current row highlighting)
        this.$.formContainer.querySelectorAll('.roster-body tr').forEach(tr => {
            tr.classList.remove('current-row');
        });
        input.closest('tr')?.classList.add('current-row');
        
        // Mark field as current
        const container = input.closest('.roster-field-container');
        container?.classList.add('current');
        
        // For inline radio/checkbox, activate to show options
        // First deactivate all other active containers
        this.$.formContainer.querySelectorAll('.roster-field-container.active').forEach(c => {
            if (c !== container) c.classList.remove('active');
        });
        // Activate this container if it's a radio/checkbox type
        if (container?.classList.contains('capture-radio') || container?.classList.contains('capture-checkbox')) {
            container.classList.add('active');
        }
        
        // Update current field tracking
        this.currentField = {
            ...field,
            roster: roster.name,
            occurrence: occurrence,
            indexes: [occurrence, 0, 0]
        };
        
        // Update status bar
        this._updateStatus(`${field.name}[${occurrence}]`);
        
        // Show CAPI/QSF for this field
        await this._showCAPI(this.currentField, this._currentPageResult);
        
        console.log('[MFC] Roster cell focus:', field.name, 'occ:', occurrence);
    }
    
    /**
     * Handle roster cell blur
     */
    _onRosterCellBlur(e, field, rowIdx, roster, input) {
        const container = input.closest('.roster-field-container');
        container?.classList.remove('current');
        // Don't remove 'active' on blur - let selection or click elsewhere handle it
    }
    
    /**
     * Handle roster cell click - MFC equivalent of OnCellField_LClicked
     * In system-controlled mode (path on), clicking should not change navigation
     * The engine controls the path - users must follow it
     */
    async _onRosterCellClick(e, field, rowIdx, roster, input) {
        const occurrence = rowIdx + 1;
        
        // Don't process if already focused
        if (document.activeElement === input) return;
        
        // Check if we're in system-controlled mode (path on)
        // In MFC, clicking in system-controlled mode doesn't let you jump around
        const isSystemControlled = this.isPathOn !== false;
        
        if (isSystemControlled) {
            // Check if clicking on a different position than where the engine is
            const engineField = this.currentField;
            if (engineField) {
                const engineOcc = engineField.indexes?.[0] || 1;
                const engineFieldName = engineField.name;
                
                // If clicking on a different field/occurrence, warn and keep focus where engine is
                if (engineFieldName !== field.name || engineOcc !== occurrence) {
                    console.log('[MFC] Roster cell click in system-controlled mode - cannot jump to', field.name, 'occ', occurrence);
                    console.log('[MFC] Engine is at:', engineFieldName, 'occ', engineOcc);
                    
                    // Flash the clicked cell to indicate it's not allowed
                    input.classList.add('click-denied');
                    setTimeout(() => input.classList.remove('click-denied'), 200);
                    
                    // Keep focus on the engine's current field instead
                    const engineRowIndex = engineOcc - 1;
                    const engineSelector = `input[data-field-name="${engineFieldName}"][data-row-index="${engineRowIndex}"]`;
                    const engineInput = this.$.formContainer.querySelector(engineSelector);
                    if (engineInput) {
                        engineInput.focus();
                    }
                    return;
                }
            }
            
            // Clicking on the current field is OK - just focus it
            console.log('[MFC] Roster cell click on current field - focusing');
            input.focus();
            if (input.select) input.select();
            return;
        }
        
        // If free navigation mode (operator-controlled), use goToField like MFC
        if (this.engine && typeof this.engine.goToField === 'function') {
            try {
                const fieldSymbol = field.symbol || 0;
                console.log('[MFC] Roster cell click - calling goToField:', field.name, 'symbol:', fieldSymbol, 'occ:', occurrence);
                this._wasmBusy = true;
                let result = this.engine.goToField(fieldSymbol, occurrence, 0, 0);
                if (result && typeof result.then === 'function') {
                    result = await result;
                }
                this._wasmBusy = false;
                
                if (result) {
                    this._currentPageResult = result;
                    console.log('[MFC] goToField result:', JSON.stringify(result).substring(0, 200));
                    
                    // Update current field from engine
                    if (result.fields && result.fields.length > 0) {
                        this.currentField = result.fields[0];
                    }
                    
                    // Show CAPI for this field
                    await this._showCAPI(this.currentField, result);
                    
                    // Update grid data from engine
                    this._updateRosterFromEngine(roster.name);
                }
            } catch (err) {
                this._wasmBusy = false;
                console.warn('[MFC] goToField failed:', err);
            }
        }
        
        // Focus the input
        input.focus();
        if (input.select) input.select();
    }
    
    /**
     * Handle roster cell keydown - MFC equivalent of processing Enter/Tab
     * CRITICAL: Always use engine advanceField to enforce CSPro logic
     * 
     * Data Entry Orientation:
     * - isPathOn=true (SystemControlled): Engine controls navigation, arrow keys blocked
     * - isPathOn=false (OperatorControlled): Free movement, arrow keys work
     * 
     * Roster Free Movement (when isPathOn=false):
     * - freeMovementMode=0 (Disabled): Follow roster path (by rows or columns)
     * - freeMovementMode=1 (Horizontal): Free horizontal movement (across columns)
     * - freeMovementMode=2 (Vertical): Free vertical movement (across rows)
     */
    async _onRosterCellKeyDown(e, field, rowIdx, roster, input) {
        const occurrence = rowIdx + 1;
        
        // Get roster orientation and free movement settings
        const rosterDiv = input.closest('.form-roster');
        const rosterOrientation = rosterDiv?.dataset.orientation || roster.orientation || 'Horizontal';
        const freeMovementMode = parseInt(rosterDiv?.dataset.freeMovementMode || roster.freeMovementMode || 0);
        // FreeMovementMode: 0=Disabled, 1=Horizontal, 2=Vertical
        
        switch (e.key) {
            case 'Enter':
                e.preventDefault();
                // In MFC CSEntry, Enter advances to next field like Tab does
                // This ensures CSPro logic (postproc, errmsg, skip, etc.) is enforced
                // MUST use engine to enforce logic - never skip this!
                {
                    const value = input.value ?? input.textContent ?? '';
                    console.log('[MFC] Roster Enter - advancing through engine:', field.name, 'value:', value);
                    await this._advanceWithValue(value);
                }
                break;
                
            case 'Tab':
                e.preventDefault();
                // Tab advances to next field through engine (enforces CSPro logic)
                {
                    const value = input.value ?? input.textContent ?? '';
                    console.log('[MFC] Roster Tab - advancing through engine:', field.name, 'value:', value);
                    if (e.shiftKey) {
                        // Shift+Tab = previous field
                        await this._advanceToPreviousField();
                    } else {
                        await this._advanceWithValue(value);
                    }
                }
                break;
                
            case 'ArrowDown':
                // Check if free vertical movement is allowed
                // In SystemControlled mode (isPathOn=true), never allow free arrow navigation
                if (this.isPathOn !== false) {
                    // Flash to indicate not allowed
                    input.classList.add('click-denied');
                    setTimeout(() => input.classList.remove('click-denied'), 200);
                    console.log('[MFC] ArrowDown blocked - SystemControlled mode');
                } else if (freeMovementMode === 2 || freeMovementMode === 0) {
                    // Free vertical movement (mode=2) OR disabled mode (follow roster path)
                    // In horizontal roster, down moves to next row
                    e.preventDefault();
                    this._moveToRosterCell(roster.name, field.name, rowIdx + 1);
                } else {
                    // FreeMovement is Horizontal only (mode=1) - vertical blocked
                    input.classList.add('click-denied');
                    setTimeout(() => input.classList.remove('click-denied'), 200);
                    console.log('[MFC] ArrowDown blocked - FreeMovement is Horizontal only');
                }
                break;
                
            case 'ArrowUp':
                // Check if free vertical movement is allowed
                if (this.isPathOn !== false) {
                    // Flash to indicate not allowed
                    input.classList.add('click-denied');
                    setTimeout(() => input.classList.remove('click-denied'), 200);
                    console.log('[MFC] ArrowUp blocked - SystemControlled mode');
                } else if (freeMovementMode === 2 || freeMovementMode === 0) {
                    // Free vertical movement (mode=2) OR disabled mode (follow roster path)
                    e.preventDefault();
                    this._moveToRosterCell(roster.name, field.name, rowIdx - 1);
                } else {
                    // FreeMovement is Horizontal only (mode=1) - vertical blocked
                    input.classList.add('click-denied');
                    setTimeout(() => input.classList.remove('click-denied'), 200);
                    console.log('[MFC] ArrowUp blocked - FreeMovement is Horizontal only');
                }
                break;
                
            case 'ArrowLeft':
                // Check if free horizontal movement is allowed
                if (this.isPathOn !== false) {
                    // In SystemControlled mode, don't block left/right for cursor movement in text
                    // Just don't change cells
                } else if (freeMovementMode === 1 || freeMovementMode === 0) {
                    // Free horizontal movement (mode=1) OR disabled mode
                    // Move to previous column (same row)
                    e.preventDefault();
                    this._moveToRosterColumn(roster.name, field.name, rowIdx, -1);
                }
                break;
                
            case 'ArrowRight':
                // Check if free horizontal movement is allowed
                if (this.isPathOn !== false) {
                    // In SystemControlled mode, don't block left/right for cursor movement in text
                } else if (freeMovementMode === 1 || freeMovementMode === 0) {
                    // Free horizontal movement (mode=1) OR disabled mode
                    // Move to next column (same row)
                    e.preventDefault();
                    this._moveToRosterColumn(roster.name, field.name, rowIdx, 1);
                }
                break;
                
            case 'Escape':
                // Revert to original value - but don't navigate
                console.log('[MFC] Roster Escape - reverting value (not implemented)');
                break;
        }
    }
    
    /**
     * Handle roster cell input - validation and auto-advance
     */
    async _onRosterCellInput(e, field, rowIdx, roster, input) {
        const isNumeric = input.dataset.isNumeric === '1';
        
        // Numeric validation
        if (isNumeric) {
            input.value = input.value.replace(/[^0-9.\-]/g, '');
        }
        
        // Uppercase if required
        if (field.isUpperCase) {
            input.value = input.value.toUpperCase();
        }
        
        // Update tickmarks if present
        const tickmarks = input.closest('.roster-field-container')?.querySelector('.roster-tickmarks');
        if (tickmarks) {
            const fieldLength = parseInt(input.maxLength) || 10;
            const decimalPlaces = field.decimalPlaces || field.fractionalPartLength || 0;
            this._updateTickmarkDisplay(input, tickmarks, fieldLength, decimalPlaces, isNumeric);
        }
        
        // Auto-advance when field is full (CSEntry behavior)
        const maxLen = parseInt(input.maxLength) || 20;
        if (input.value.length >= maxLen && this.isPathOn) {
            await this._advanceWithValue(input.value);
        }
    }
    
    /**
     * Move to a specific roster cell
     */
    _moveToRosterCell(rosterName, fieldName, rowIdx) {
        const rosterInfo = this._rosters?.[rosterName];
        if (!rosterInfo) return;
        
        const maxOcc = rosterInfo.data.maxOccurrences || 20;
        rowIdx = Math.max(0, Math.min(maxOcc - 1, rowIdx));
        
        const selector = `[data-roster-name="${rosterName}"] input[data-field-name="${fieldName}"][data-row-index="${rowIdx}"]`;
        const input = this.$.formContainer.querySelector(selector);
        if (input) {
            input.focus();
            if (input.select) input.select();
        }
    }
    
    /**
     * Move to a different column in the same roster row (for horizontal free movement)
     * @param {string} rosterName - The roster name
     * @param {string} currentFieldName - Current field name
     * @param {number} rowIdx - Current row index (0-based)
     * @param {number} direction - -1 for previous column, +1 for next column
     */
    _moveToRosterColumn(rosterName, currentFieldName, rowIdx, direction) {
        const rosterInfo = this._rosters?.[rosterName];
        if (!rosterInfo) return;
        
        const roster = rosterInfo.data;
        const columns = roster.columns || [];
        
        // Find current column index
        let currentColIdx = -1;
        for (let cIdx = 0; cIdx < columns.length; cIdx++) {
            const col = columns[cIdx];
            if (col.fields?.some(f => f.name === currentFieldName || f.itemName === currentFieldName)) {
                currentColIdx = cIdx;
                break;
            }
        }
        
        if (currentColIdx < 0) return;
        
        // Calculate target column
        const targetColIdx = currentColIdx + direction;
        if (targetColIdx < 0 || targetColIdx >= columns.length) return;
        
        // Get first field in target column
        const targetCol = columns[targetColIdx];
        const targetField = targetCol.fields?.[0];
        if (!targetField) return;
        
        const targetFieldName = targetField.name || targetField.itemName;
        const selector = `[data-roster-name="${rosterName}"] input[data-field-name="${targetFieldName}"][data-row-index="${rowIdx}"]`;
        const input = this.$.formContainer.querySelector(selector);
        if (input) {
            input.focus();
            if (input.select) input.select();
        }
    }
    
    /**
     * Update a field's display with a value - used after dialog selection
     * This ensures the selected value is visible in the roster/form before advancing
     * @param {Object} field - Field object with name and indexes
     * @param {string} value - The value to display
     */
    _updateFieldDisplayValue(field, value) {
        console.log('[MFC] _updateFieldDisplayValue:', field.name, 'indexes:', field.indexes, 'value:', value);
        
        let input = null;
        const isRosterField = field.indexes && field.indexes.length > 0 && field.indexes[0] > 0;
        
        if (isRosterField) {
            const rowIndex = field.indexes[0] - 1;
            // Try to find the input in the roster
            input = this.$.formContainer.querySelector(
                `input[data-field-name="${field.name}"][data-row-index="${rowIndex}"]`
            );
            // If not found, try container
            if (!input) {
                const container = this.$.formContainer.querySelector(
                    `.roster-field-container[data-field-name="${field.name}"][data-row-index="${rowIndex}"]`
                );
                if (container) {
                    input = container.querySelector('input');
                }
            }
        } else {
            // Standalone field
            input = this.$.formContainer.querySelector(`input[data-field-name="${field.name}"]`);
        }
        
        if (input) {
            input.value = value;
            const isNumeric = input.dataset.isNumeric === '1' || field.isNumeric;
            
            // Update tickmarks if present
            const tickmarks = input.closest('.roster-field-container')?.querySelector('.roster-tickmarks');
            if (tickmarks) {
                const fieldLength = parseInt(input.maxLength) || 10;
                const decimalPlaces = field.fractionalPartLength || 0;
                this._updateTickmarkDisplay(input, tickmarks, fieldLength, decimalPlaces, isNumeric);
            }
            
            console.log('[MFC] Updated field display:', field.name, 'value:', value);
        } else {
            console.warn('[MFC] Could not find input for field:', field.name, 'indexes:', field.indexes);
        }
    }
    
    /**
     * Update roster display from engine data - like MFC SetGridData
     * This reads values from engine and updates the grid cells
     */
    async _updateRosterFromEngine(rosterName) {
        if (!this.engine) return;
        
        const rosterInfo = this._rosters?.[rosterName];
        if (!rosterInfo) return;
        
        console.log('[MFC] Updating roster from engine:', rosterName);
        
        // Get current page from engine
        let pageResult = this._currentPageResult;
        if (!pageResult && this.engine.getCurrentPage) {
            pageResult = this.engine.getCurrentPage();
            if (pageResult && typeof pageResult.then === 'function') {
                pageResult = await pageResult;
            }
            this._currentPageResult = pageResult;
        }
        
        // For each field in the page result that belongs to this roster,
        // update the corresponding cell
        if (pageResult && pageResult.fields) {
            pageResult.fields.forEach(field => {
                if (field.indexes && field.indexes[0] > 0) {
                    const rowIdx = field.indexes[0] - 1;
                    const selector = `[data-roster-name="${rosterName}"] input[data-field-name="${field.name}"][data-row-index="${rowIdx}"]`;
                    const input = this.$.formContainer.querySelector(selector);
                    if (input) {
                        // Set value from engine
                        const value = field.alphaValue || (field.numericValue !== undefined ? field.numericValue.toString() : '');
                        const isNumeric = input.dataset.isNumeric === '1';
                        if (input.value !== value) {
                            input.value = value;
                            // Update tickmarks
                            const tickmarks = input.closest('.roster-field-container')?.querySelector('.roster-tickmarks');
                            if (tickmarks) {
                                const fieldLength = parseInt(input.maxLength) || 10;
                                this._updateTickmarkDisplay(input, tickmarks, fieldLength, 0, isNumeric);
                            }
                        }
                    }
                }
            });
        }
    }
    
    /**
     * Create numeric input with tickmarks for roster cells
     * @deprecated Use _createRosterCellInput instead
     */
    _createRosterTickmarkInput(field, rowIdx, rosterName, length, decimalPlaces) {
        const container = document.createElement('div');
        container.className = 'roster-tickmark-container';
        container.dataset.fieldName = field.name;
        container.dataset.rosterName = rosterName;
        container.dataset.rowIndex = rowIdx;
        container.dataset.occurrence = rowIdx + 1;
        
        // Hidden input for actual value
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'roster-tickmark-input';
        input.dataset.fieldName = field.name;
        input.dataset.rosterName = rosterName;
        input.dataset.rowIndex = rowIdx;
        input.dataset.occurrence = rowIdx + 1;
        input.maxLength = length + (decimalPlaces > 0 ? 1 : 0);
        
        if (field.isProtected) {
            input.readOnly = true;
            container.classList.add('protected');
        }
        
        // Create tickmark boxes
        const tickmarks = document.createElement('div');
        tickmarks.className = 'roster-tickmarks';
        
        const totalChars = length;
        const integerChars = decimalPlaces > 0 ? length - decimalPlaces : length;
        
        for (let i = 0; i < totalChars; i++) {
            const tick = document.createElement('span');
            tick.className = 'roster-tick';
            // Add decimal marker
            if (decimalPlaces > 0 && i === integerChars) {
                tick.classList.add('decimal-point');
            }
            tickmarks.appendChild(tick);
        }
        
        container.appendChild(input);
        container.appendChild(tickmarks);
        
        // Update tickmark display on input
        input.addEventListener('input', () => {
            this._updateRosterTickmarks(input, tickmarks, totalChars, decimalPlaces);
            this._onRosterFieldInput({ name: rosterName }, field, rowIdx, input);
        });
        
        // Field events
        input.addEventListener('focus', () => {
            container.classList.add('focused');
            this._onRosterFieldFocus({ name: rosterName }, field, rowIdx, input);
        });
        input.addEventListener('blur', () => {
            container.classList.remove('focused');
            this._onRosterFieldBlur({ name: rosterName }, field, rowIdx, input);
        });
        input.addEventListener('keydown', (e) => this._onRosterFieldKeyDown(e, { name: rosterName }, field, rowIdx, input));
        
        return container;
    }
    
    /**
     * Update tickmark display to show characters in boxes
     */
    _updateRosterTickmarks(input, tickmarks, totalChars, decimalPlaces) {
        const value = input.value.replace('.', ''); // Remove decimal for display
        const ticks = tickmarks.querySelectorAll('.roster-tick');
        
        // Right-align the value in the tickmarks
        const startPos = totalChars - value.length;
        
        ticks.forEach((tick, i) => {
            const charIndex = i - startPos;
            if (charIndex >= 0 && charIndex < value.length) {
                tick.textContent = value[charIndex];
            } else {
                tick.textContent = '';
            }
        });
    }
    
    /**
     * CaptureType enum values from CSPro engine (zDictO/CaptureInfo.h)
     * 0 = TextBox, 1 = RadioButton, 2 = CheckBox, 3 = DropDown, 4 = ComboBox,
     * 5 = Date, 6 = NumberPad, 7 = Barcode, 8 = Slider, 9 = ToggleButton
     */
    static CAPTURE_TYPES = {
        TextBox: 0,
        RadioButton: 1,
        CheckBox: 2,
        DropDown: 3,
        ComboBox: 4,
        Date: 5,
        NumberPad: 6,
        Barcode: 7,
        Slider: 8,
        ToggleButton: 9
    };
    
    /**
     * Create field input element based on capture type from engine
     * MFC-style rendering matching CSEntry Windows behavior
     * @param {Object} field - Field object with engine properties
     * @param {number} fieldIndex - Index of field in form
     * @returns {HTMLElement} - The created element
     */
    _createFieldElement(field, fieldIndex) {
        const captureType = field.captureType ?? 0; // Default to TextBox
        const responses = field.responses || [];
        const isNumeric = field.isNumeric || field.type === 'numeric';
        
        console.log(`Creating field ${field.name} with captureType=${captureType}, responses=${responses.length}`);
        
        // CaptureType: RadioButton (1) - Use radio buttons for value set
        if (captureType === CSEntryMFCView.CAPTURE_TYPES.RadioButton && responses.length > 0) {
            return this._createRadioButtonGroup(field, fieldIndex, responses);
        }
        
        // CaptureType: CheckBox (2) - Use checkboxes for multiple selection
        if (captureType === CSEntryMFCView.CAPTURE_TYPES.CheckBox && responses.length > 0) {
            return this._createCheckboxGroup(field, fieldIndex, responses);
        }
        
        // CaptureType: DropDown (3) - Use select dropdown (selection only, no text input)
        if (captureType === CSEntryMFCView.CAPTURE_TYPES.DropDown && responses.length > 0) {
            return this._createDropdown(field, fieldIndex, responses);
        }
        
        // CaptureType: ComboBox (4) - Use combobox (text input + dropdown suggestions)
        // ComboBox allows both typing any value AND selecting from list
        if (captureType === CSEntryMFCView.CAPTURE_TYPES.ComboBox && responses.length > 0) {
            return this._createComboBox(field, fieldIndex, responses);
        }
        
        // CaptureType: Slider (8)
        if (captureType === CSEntryMFCView.CAPTURE_TYPES.Slider) {
            return this._createSlider(field, fieldIndex);
        }
        
        // CaptureType: Date (5)
        if (captureType === CSEntryMFCView.CAPTURE_TYPES.Date) {
            return this._createDateInput(field, fieldIndex);
        }
        
        // Default: TextBox (0), NumberPad (6), Barcode (7), ToggleButton (9)
        // For numeric fields with tickmarks
        if (isNumeric && field.integerPartLength) {
            return this._createNumericTickmarkInput(field, fieldIndex);
        }
        
        // Standard text input
        return this._createTextInput(field, fieldIndex);
    }
    
    /**
     * Create standard text input field
     */
    _createTextInput(field, fieldIndex) {
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'form-field-input' + 
            (field.isNumeric || field.type === 'numeric' ? ' numeric' : '') +
            (field.isUpperCase ? ' uppercase' : '');
        input.dataset.fieldName = field.name;
        input.dataset.fieldIndex = fieldIndex;
        input.dataset.occurrence = '1';
        input.maxLength = field.length || field.alphaLength || field.integerPartLength || 20;
        return input;
    }
    
    /**
     * Create numeric field with MFC-style tickmarks showing character positions
     */
    _createNumericTickmarkInput(field, fieldIndex) {
        const container = document.createElement('div');
        container.className = 'form-field-tickmark-container';
        container.dataset.fieldName = field.name;
        container.dataset.fieldIndex = fieldIndex;
        
        const totalLength = (field.integerPartLength || 0) + (field.fractionalPartLength || 0);
        const charWidth = 9; // Approximate character width in monospace font
        const inputWidth = totalLength * charWidth + 8; // Add padding
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'form-field-tickmark-input numeric';
        input.dataset.fieldName = field.name;
        input.dataset.fieldIndex = fieldIndex;
        input.dataset.occurrence = '1';
        input.maxLength = totalLength + (field.fractionalPartLength > 0 ? 1 : 0); // +1 for decimal point
        input.style.width = inputWidth + 'px';
        
        // Create tickmark overlay
        const tickmarks = document.createElement('div');
        tickmarks.className = 'form-field-tickmarks';
        
        // Create tick marks for each character position
        for (let i = 0; i < totalLength; i++) {
            const tick = document.createElement('div');
            tick.className = 'tickmark-char';
            // Mark the decimal position with a special style
            if (field.fractionalPartLength > 0 && i === field.integerPartLength - 1) {
                tick.classList.add('tickmark-decimal');
            }
            tickmarks.appendChild(tick);
        }
        
        container.appendChild(input);
        container.appendChild(tickmarks);
        return container;
    }
    
    /**
     * Create radio button group for single selection value sets
     */
    _createRadioButtonGroup(field, fieldIndex, responses) {
        const container = document.createElement('div');
        container.className = 'form-field-radio-group';
        container.dataset.fieldName = field.name;
        container.dataset.fieldIndex = fieldIndex;
        container.dataset.captureType = 'radio';
        
        const groupName = `radio_${field.name}_${fieldIndex}`;
        
        responses.forEach((resp, idx) => {
            const option = document.createElement('label');
            option.className = 'form-field-radio-option';
            
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = groupName;
            radio.value = resp.code;
            radio.dataset.responseIndex = idx;
            
            const code = document.createElement('span');
            code.className = 'option-code';
            code.textContent = resp.code;
            
            const label = document.createElement('span');
            label.className = 'option-label';
            label.textContent = resp.label;
            
            // Apply text color if set
            if (resp.textColor && resp.textColor !== 0) {
                const r = (resp.textColor >> 16) & 0xFF;
                const g = (resp.textColor >> 8) & 0xFF;
                const b = resp.textColor & 0xFF;
                label.style.color = `rgb(${r},${g},${b})`;
            }
            
            option.appendChild(radio);
            option.appendChild(code);
            option.appendChild(label);
            container.appendChild(option);
            
            // Handle selection
            radio.addEventListener('change', () => {
                this._onCaptureTypeValueChange(field, resp.code);
            });
        });
        
        return container;
    }
    
    /**
     * Create checkbox group for multiple selection value sets
     */
    _createCheckboxGroup(field, fieldIndex, responses) {
        const container = document.createElement('div');
        container.className = 'form-field-checkbox-group';
        container.dataset.fieldName = field.name;
        container.dataset.fieldIndex = fieldIndex;
        container.dataset.captureType = 'checkbox';
        container.dataset.maxSelections = field.maxCheckboxSelections || responses.length;
        
        responses.forEach((resp, idx) => {
            const option = document.createElement('label');
            option.className = 'form-field-checkbox-option';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = resp.code;
            checkbox.dataset.responseIndex = idx;
            
            const code = document.createElement('span');
            code.className = 'option-code';
            code.textContent = resp.code;
            
            const label = document.createElement('span');
            label.className = 'option-label';
            label.textContent = resp.label;
            
            // Apply text color if set
            if (resp.textColor && resp.textColor !== 0) {
                const r = (resp.textColor >> 16) & 0xFF;
                const g = (resp.textColor >> 8) & 0xFF;
                const b = resp.textColor & 0xFF;
                label.style.color = `rgb(${r},${g},${b})`;
            }
            
            option.appendChild(checkbox);
            option.appendChild(code);
            option.appendChild(label);
            container.appendChild(option);
            
            // Handle selection with max limit check
            checkbox.addEventListener('change', () => {
                this._onCheckboxChange(field, container);
            });
        });
        
        return container;
    }
    
    /**
     * Create dropdown select for value sets
     */
    _createDropdown(field, fieldIndex, responses) {
        const select = document.createElement('select');
        select.className = 'form-field-dropdown';
        select.dataset.fieldName = field.name;
        select.dataset.fieldIndex = fieldIndex;
        select.dataset.captureType = 'dropdown';
        select.dataset.occurrence = '1';
        
        // Add empty option
        const emptyOpt = document.createElement('option');
        emptyOpt.value = '';
        emptyOpt.textContent = '-- Select --';
        select.appendChild(emptyOpt);
        
        responses.forEach((resp, idx) => {
            const opt = document.createElement('option');
            opt.value = resp.code;
            opt.textContent = `${resp.code} - ${resp.label}`;
            opt.dataset.responseIndex = idx;
            select.appendChild(opt);
        });
        
        select.addEventListener('change', () => {
            this._onCaptureTypeValueChange(field, select.value);
        });
        
        return select;
    }
    
    /**
     * Create combobox input with datalist for value sets
     * ComboBox allows user to type any value OR select from list (unlike DropDown which is select-only)
     */
    _createComboBox(field, fieldIndex, responses) {
        const container = document.createElement('div');
        container.className = 'form-field-combobox';
        container.dataset.fieldName = field.name;
        container.dataset.fieldIndex = fieldIndex;
        container.dataset.captureType = 'combobox';
        
        // Create text input
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'form-field-combobox-input' + 
            (field.isNumeric || field.type === 'numeric' ? ' numeric' : '');
        input.dataset.fieldName = field.name;
        input.dataset.fieldIndex = fieldIndex;
        input.dataset.occurrence = '1';
        input.maxLength = field.length || field.alphaLength || field.integerPartLength || 20;
        input.placeholder = 'Type or select...';
        
        // Create datalist for dropdown suggestions
        const datalistId = `datalist_${field.name}_${fieldIndex}`;
        const datalist = document.createElement('datalist');
        datalist.id = datalistId;
        
        responses.forEach((resp, idx) => {
            const opt = document.createElement('option');
            opt.value = resp.code;
            // Include label as data attribute for display
            opt.dataset.label = resp.label;
            opt.textContent = `${resp.code} - ${resp.label}`;
            datalist.appendChild(opt);
        });
        
        input.setAttribute('list', datalistId);
        
        // Handle value change
        input.addEventListener('change', () => {
            this._onCaptureTypeValueChange(field, input.value);
        });
        
        // Also trigger on input for immediate feedback
        input.addEventListener('input', () => {
            // Optional: validate against responses or allow any value
        });
        
        container.appendChild(input);
        container.appendChild(datalist);
        
        return container;
    }
    
    /**
     * Create slider control
     */
    _createSlider(field, fieldIndex) {
        const container = document.createElement('div');
        container.className = 'form-field-slider-container';
        container.dataset.fieldName = field.name;
        container.dataset.fieldIndex = fieldIndex;
        container.dataset.captureType = 'slider';
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.className = 'form-field-slider';
        slider.min = field.sliderMinValue || 0;
        slider.max = field.sliderMaxValue || 100;
        slider.step = field.sliderStep || 1;
        slider.value = field.sliderMinValue || 0;
        slider.dataset.fieldName = field.name;
        slider.dataset.occurrence = '1';
        
        const valueDisplay = document.createElement('span');
        valueDisplay.className = 'form-field-slider-value';
        valueDisplay.textContent = slider.value;
        
        slider.addEventListener('input', () => {
            valueDisplay.textContent = slider.value;
        });
        
        slider.addEventListener('change', () => {
            this._onCaptureTypeValueChange(field, slider.value);
        });
        
        container.appendChild(slider);
        container.appendChild(valueDisplay);
        return container;
    }
    
    /**
     * Create date input field
     */
    _createDateInput(field, fieldIndex) {
        const input = document.createElement('input');
        input.type = 'date';
        input.className = 'form-field-date';
        input.dataset.fieldName = field.name;
        input.dataset.fieldIndex = fieldIndex;
        input.dataset.captureType = 'date';
        input.dataset.occurrence = '1';
        return input;
    }
    
    /**
     * Handle value change for capture type controls
     */
    async _onCaptureTypeValueChange(field, value) {
        console.log(`[MFC] Capture type value changed for ${field.name}: ${value}`);
        // Store the value
        this._storeFieldValue(field.name, value, 1);
        // Auto-advance to next field
        if (this.isPathOn) {
            await this._advanceWithValue(value);
        }
    }
    
    /**
     * Handle checkbox selection with max limit enforcement
     */
    _onCheckboxChange(field, container) {
        const maxSelections = parseInt(container.dataset.maxSelections) || 999;
        const checkboxes = container.querySelectorAll('input[type="checkbox"]');
        const checkedBoxes = container.querySelectorAll('input[type="checkbox"]:checked');
        
        // If max reached, disable unchecked boxes
        if (checkedBoxes.length >= maxSelections) {
            checkboxes.forEach(cb => {
                if (!cb.checked) cb.disabled = true;
            });
        } else {
            checkboxes.forEach(cb => cb.disabled = false);
        }
        
        // Build value from checked items (concatenated codes)
        const values = Array.from(checkedBoxes).map(cb => cb.value);
        const value = values.join(',');
        
        console.log(`[MFC] Checkbox value changed for ${field.name}: ${value}`);
        this._storeFieldValue(field.name, value, 1);
    }
    
    /**
     * Get the current value from a field element based on its capture type
     */
    _getFieldElementValue(element) {
        if (!element) return '';
        
        const captureType = element.dataset.captureType;
        
        if (captureType === 'radio') {
            const checked = element.querySelector('input[type="radio"]:checked');
            return checked ? checked.value : '';
        }
        
        if (captureType === 'checkbox') {
            const checked = element.querySelectorAll('input[type="checkbox"]:checked');
            return Array.from(checked).map(cb => cb.value).join(',');
        }
        
        if (captureType === 'dropdown') {
            return element.value || '';
        }
        
        if (captureType === 'slider') {
            const slider = element.querySelector('input[type="range"]');
            return slider ? slider.value : '';
        }
        
        if (captureType === 'date') {
            return element.value || '';
        }
        
        // Default: text input
        if (element.classList.contains('form-field-tickmark-container')) {
            const input = element.querySelector('input');
            return input ? input.value : '';
        }
        
        return element.value || '';
    }

    /**
     * Build the navigation field list from form structure
     * This creates a flat list of all fields in the order they should be navigated
     * (matching CSEntry MFC behavior)
     */
    _buildNavigationFields(form) {
        this.navigationFields = [];
        
        // First, add standalone fields (in form order, sorted by Y then X position)
        const standaloneFields = (form.fields || []).map(f => ({
            name: f.name,
            field: f,
            occurrence: 1,
            rosterName: null,
            y: f.y || 0,
            x: f.x || 0,
            value: ''
        }));
        
        // Sort by Y position (top to bottom), then X (left to right)
        standaloneFields.sort((a, b) => {
            if (Math.abs(a.y - b.y) > 10) return a.y - b.y;
            return a.x - b.x;
        });
        
        this.navigationFields.push(...standaloneFields);
        
        // Then, add roster fields
        // For each roster, we navigate column by column within each row
        (form.rosters || []).forEach(roster => {
            const maxOcc = Math.min(roster.maxOccurrences || 20, 10); // Limit visible rows
            
            for (let rowIdx = 0; rowIdx < maxOcc; rowIdx++) {
                // For each row, add fields from each column in order
                (roster.columns || []).forEach(col => {
                    (col.fields || []).forEach(field => {
                        this.navigationFields.push({
                            name: field.name,
                            field: field,
                            occurrence: rowIdx + 1,
                            rosterName: roster.name,
                            y: roster.y + rowIdx * 20,
                            x: roster.x,
                            value: ''
                        });
                    });
                });
            }
        });
        
        console.log(`Built navigation with ${this.navigationFields.length} fields`);
    }
    
    _onRosterFieldFocus(roster, field, rowIdx, input) {
        // Highlight current row
        this.$.formContainer.querySelectorAll('.roster-body tr').forEach(tr => {
            tr.classList.remove('current-row');
        });
        input.closest('tr')?.classList.add('current-row');
        
        this.currentField = {
            ...field,
            roster: roster.name,
            occurrence: rowIdx + 1
        };
        
        // Update navigation index to match focused field
        const occurrence = rowIdx + 1;
        const navIdx = this.navigationFields.findIndex(nf => 
            nf.name === field.name && nf.occurrence === occurrence && nf.rosterName === roster.name
        );
        if (navIdx >= 0) {
            this.currentNavIndex = navIdx;
        }
        
        this._updateStatus(`${field.name}[${rowIdx + 1}]`);
    }
    
    _onRosterFieldBlur(roster, field, rowIdx, input) {
        // Store the value
        const occurrence = rowIdx + 1;
        const navIdx = this.navigationFields.findIndex(nf => 
            nf.name === field.name && nf.occurrence === occurrence && nf.rosterName === roster.name
        );
        if (navIdx >= 0) {
            this.navigationFields[navIdx].value = input.value;
        }
    }
    
    async _onRosterFieldKeyDown(e, roster, field, rowIdx, input) {
        switch (e.key) {
            case 'Enter':
                e.preventDefault();
                // Use native engine for logic execution
                await this._advanceWithValue(input.value);
                break;
            case 'Tab':
                e.preventDefault();
                // Use navigation system
                if (e.shiftKey) {
                    this._advanceToPreviousField();
                } else {
                    await this._advanceWithValue(input.value);
                }
                break;
            case 'ArrowDown':
                e.preventDefault();
                this._moveToRosterRow(roster, field.name, rowIdx + 1);
                break;
            case 'ArrowUp':
                e.preventDefault();
                this._moveToRosterRow(roster, field.name, rowIdx - 1);
                break;
        }
    }
    
    _onRosterFieldInput(roster, field, rowIdx, input) {
        // Numeric validation for numeric fields
        if (field.isNumeric) {
            input.value = input.value.replace(/[^0-9.-]/g, '');
        }
        
        // Store value in navigation field
        const occurrence = rowIdx + 1;
        const navIdx = this.navigationFields.findIndex(nf => 
            nf.name === field.name && nf.occurrence === occurrence && nf.rosterName === roster.name
        );
        if (navIdx >= 0) {
            this.navigationFields[navIdx].value = input.value;
        }
        
        // Auto-advance when field is full (CSEntry behavior)
        const maxLen = field.length || input.maxLength || 20;
        if (input.value.length >= maxLen && this.isPathOn) {
            this._advanceToNextField();
        }
    }
    
    _moveToRosterRow(roster, fieldName, newRowIdx) {
        const maxOcc = roster.maxOccurrences || 20;
        newRowIdx = Math.max(0, Math.min(maxOcc - 1, newRowIdx));
        
        const input = this.$.formContainer.querySelector(
            `[data-field-name="${fieldName}"][data-row-index="${newRowIdx}"]`
        );
        if (input) input.focus();
    }

    _onFieldFocus(field, input) {
        this.currentField = field;
        this.fieldIndex = this.currentForm.fields?.indexOf(field) ?? -1;
        
        // Update navigation index to match focused field
        const navIdx = this.navigationFields.findIndex(nf => 
            nf.name === field.name && nf.occurrence === (parseInt(input.dataset.occurrence) || 1)
        );
        if (navIdx >= 0) {
            this.currentNavIndex = navIdx;
        }
        
        this._showCAPI(field);
        this._highlightTreeField(field.name);
        
        const occ = input.dataset.occurrence ? `[${input.dataset.occurrence}]` : '';
        this._updateStatus(field.name + occ);
    }

    _onFieldBlur(field, input) {
        input.classList.add('visited');
        this._updateTreeValue(field.name, input.value);
        
        // Store value in field data
        this._storeFieldValue(field.name, input.value, parseInt(input.dataset.occurrence) || 1);
    }

    async _onFieldKeyDown(e, field, input) {
        switch (e.key) {
            case 'Enter':
                e.preventDefault();
                // CSEntry behavior: Enter advances to next field
                // ALWAYS use engine advanceField to trigger CSPro logic (postproc, errmsg, skip)
                console.log('[MFC] Field Enter - advancing through engine:', field.name, 'value:', input.value);
                await this._advanceWithValue(input.value);
                break;
            case 'Tab':
                e.preventDefault();
                console.log('[MFC] Field Tab - advancing through engine:', field.name, 'value:', input.value);
                if (e.shiftKey) {
                    this._advanceToPreviousField();
                } else {
                    // ALWAYS use engine advanceField to trigger CSPro logic
                    await this._advanceWithValue(input.value);
                }
                break;
            case 'Escape':
                // Restore original value but don't navigate
                const navField = this.navigationFields[this.currentNavIndex];
                if (navField) {
                    input.value = navField.value || '';
                }
                break;
            case 'ArrowUp':
            case 'ArrowDown':
                // In system-controlled mode (path on), arrow keys don't navigate freely
                if (this.isPathOn !== false) {
                    // Don't prevent default - allow normal input behavior
                } else if (input.dataset.rosterName) {
                    e.preventDefault();
                    if (e.key === 'ArrowUp') {
                        this._advanceToPreviousField();
                    } else {
                        this._advanceToNextField();
                    }
                }
                break;
        }
    }

    async _onFieldInput(field, input) {
        // Numeric validation
        if (field.type === 'numeric' || field.captureType === 'NumberPad') {
            input.value = input.value.replace(/[^0-9.-]/g, '');
        }
        
        // Uppercase if required
        if (field.isUpperCase) {
            input.value = input.value.toUpperCase();
        }
        
        // Auto-advance when field is full (CSEntry behavior)
        const maxLen = field.length || field.width || 20;
        if (input.value.length >= maxLen && this.isPathOn) {
            // Validate against value set if present
            if (field.valueSet && field.valueSet.length > 0) {
                const match = field.valueSet.find(v => v.code === input.value);
                if (!match) {
                    input.classList.add('error');
                    this._showValidationError(`Invalid value. Must be one of the allowed values.`);
                    return;
                }
                input.classList.remove('error');
            }
            // Use native engine for logic execution
            await this._advanceWithValue(input.value);
        }
    }
    
    /**
     * Store field value in navigation data
     */
    _storeFieldValue(fieldName, value, occurrence = 1) {
        const navField = this.navigationFields.find(nf => 
            nf.name === fieldName && nf.occurrence === occurrence
        );
        if (navField) {
            navField.value = value;
        }
    }
    
    /**
     * Show validation error message
     */
    _showValidationError(message) {
        // Flash the status bar with error
        this.$.statusField.textContent = `Error: ${message}`;
        this.$.statusField.style.color = 'red';
        setTimeout(() => {
            this.$.statusField.style.color = '';
            this._updateStatus(this.currentField?.name || 'Ready');
        }, 2000);
    }

    async _showCAPI(field, pageResult = null) {
        // Use the modular question text handler if available
        if (this._questionTextHandler) {
            try {
                await this._questionTextHandler.displayQuestionText(field, pageResult);
                // Also show the value set below if needed (this part still uses inline display logic)
            } catch (e) {
                console.warn('[MFC] Question text handler error, falling back:', e);
            }
        }
        
        // Try to get question text from native engine if available
        let questionText = field.questionText || '';
        let questionTextHtml = null;
        let questionTextUrl = field.questionTextUrl || null;
        
        // Check for block-level question text from page result (getCurrentPage/setFieldValueAndAdvance)
        // This is critical for QSF display - the engine provides the URL in the page result
        if (!questionTextUrl && pageResult?.blockQuestionTextUrl) {
            questionTextUrl = pageResult.blockQuestionTextUrl;
            console.log('[MFC] Using blockQuestionTextUrl:', questionTextUrl);
        }
        
        // Also check stored page result
        if (!questionTextUrl && this._currentPageResult?.blockQuestionTextUrl) {
            questionTextUrl = this._currentPageResult.blockQuestionTextUrl;
            console.log('[MFC] Using stored blockQuestionTextUrl:', questionTextUrl);
        }
        
        // Also check field-level question text URL from page result fields
        if (!questionTextUrl && pageResult?.fields?.[0]?.questionTextUrl) {
            questionTextUrl = pageResult.fields[0].questionTextUrl;
            console.log('[MFC] Using field-level questionTextUrl:', questionTextUrl);
        }
        
        // Try to get question text from engine/proxy
        if (this.engine && typeof this.engine.getQuestionText === 'function' && !this._wasmBusy) {
            try {
                let qtData = this.engine.getQuestionText();
                // Handle Promise if using server API proxy
                if (qtData && typeof qtData.then === 'function') {
                    qtData = await qtData;
                }
                if (qtData) {
                    // Prefer the actual HTML content over URL
                    if (qtData.questionTextHtml) {
                        questionTextHtml = qtData.questionTextHtml;
                        console.log('[MFC] Question text HTML loaded from engine, length:', questionTextHtml.length);
                    } else if (qtData.questionTextUrl && !questionTextUrl) {
                        questionTextUrl = qtData.questionTextUrl;
                        console.log('[MFC] Question text URL from engine:', qtData.questionTextUrl);
                    }
                }
            } catch (e) {
                // If we get an error about multiple async operations, ignore it
                if (e.message && e.message.includes('multiple async')) {
                    console.log('[MFC] Skipping getQuestionText - async operation in progress');
                } else {
                    console.warn('[MFC] Could not get question text:', e);
                }
            }
        }
        
        // If we have a URL but no HTML, try to fetch from WASM virtual file system
        if (!questionTextHtml && questionTextUrl && this._wasmModule) {
            try {
                // Use the exposed getVirtualFileContent function if available
                if (typeof this._wasmModule.getVirtualFileContent === 'function') {
                    console.log('[MFC] Trying to read question text via getVirtualFileContent:', questionTextUrl);
                    const content = this._wasmModule.getVirtualFileContent(questionTextUrl);
                    if (content && content.length > 0) {
                        questionTextHtml = content;
                        console.log('[MFC] Read question text from virtual FS, length:', content.length);
                    }
                } else if (this._wasmModule.FS) {
                    // Fallback to Emscripten FS (won't work for cspro-virtual:// URLs)
                    const virtualPath = questionTextUrl.replace('cspro-virtual://', '/');
                    console.log('[MFC] Trying to read question text from Emscripten FS:', virtualPath);
                    const content = this._wasmModule.FS.readFile(virtualPath, { encoding: 'utf8' });
                    if (content) {
                        questionTextHtml = content;
                        console.log('[MFC] Read question text from FS, length:', content.length);
                    }
                }
            } catch (e) {
                console.log('[MFC] Could not read question text file:', e.message);
            }
        }
        
        // Collect content parts
        let headerContent = '';
        
        // If we have question text HTML from the virtual file system, display it in an iframe
        if (questionTextHtml) {
            // Revoke any previous blob URL
            if (this._capiBlobUrl) {
                URL.revokeObjectURL(this._capiBlobUrl);
            }
            
            // Inject CSProActionInvoker shim for CAPI HTML that uses CSPro desktop APIs
            // This allows the CAPI HTML to call actions that we handle in the web environment
            // The shim mimics the real CSProActionInvoker class from action-invoker.js
            const actionInvokerShim = `
<script>
// CSProActionInvoker class shim for web environment
// Mimics the real CSProActionInvoker from CSPro runtime
class CSProActionInvoker {
    static $Impl = {
        createMessage: function(aiThis, action, args, requestId) {
            return JSON.stringify({
                accessToken: aiThis.accessToken,
                action: action,
                arguments: (args === undefined || typeof args === "string") ? args : JSON.stringify(args),
                requestId: requestId,
                url: window.location.href
            });
        },
        processResponse: function(responseJson) {
            try {
                const response = JSON.parse(responseJson);
                if (response.type === "exception") {
                    throw new Error(response.value);
                }
                return response.value;
            } catch(e) {
                console.warn('[CAPI] processResponse error:', e);
                return responseJson;
            }
        },
        usingWindows: function() { return false; }, // We're in web environment
        run: function(aiThis, actionCode, args) {
            console.log('[CAPI] CSProActionInvoker.$Impl.run:', actionCode, args);
            // Post message to parent to handle the action
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({ 
                    type: 'cspro-action', 
                    actionCode: actionCode, 
                    args: args,
                    accessToken: aiThis.accessToken
                }, '*');
            }
            // Return empty/default response for synchronous calls
            return '';
        },
        runAsync: function(aiThis, actionCode, args) {
            console.log('[CAPI] CSProActionInvoker.$Impl.runAsync:', actionCode, args);
            return new Promise((resolve, reject) => {
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({ 
                        type: 'cspro-action-async', 
                        actionCode: actionCode, 
                        args: args,
                        accessToken: aiThis.accessToken
                    }, '*');
                }
                // For now, resolve immediately with empty result
                resolve('');
            });
        }
    };

    constructor(accessToken) {
        this.accessToken = accessToken;
    }

    getWindowForEventListener() {
        return window;
    }

    // Main execute methods
    execute(args) { return CSProActionInvoker.$Impl.run(this, 11276, args); }
    executeAsync(args) { return CSProActionInvoker.$Impl.runAsync(this, 11276, args); }

    // UI namespace
    UI = {
        alert: (args) => { return CSProActionInvoker.$Impl.run(this, 31133, args); },
        alertAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 31133, args); },
        closeDialog: (args) => { return CSProActionInvoker.$Impl.run(this, 60265, args); },
        closeDialogAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 60265, args); },
        getInputData: (args) => { return CSProActionInvoker.$Impl.run(this, 57200, args); },
        getInputDataAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 57200, args); },
        showDialog: (args) => { return CSProActionInvoker.$Impl.run(this, 49835, args); },
        showDialogAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 49835, args); },
        view: (args) => { return CSProActionInvoker.$Impl.run(this, 50017, args); },
        viewAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 50017, args); }
    };

    // Logic namespace
    Logic = {
        eval: (args) => { return CSProActionInvoker.$Impl.run(this, 50799, args); },
        evalAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 50799, args); },
        getSymbol: (args) => { return CSProActionInvoker.$Impl.run(this, 44034, args); },
        getSymbolAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 44034, args); },
        getSymbolValue: (args) => { return CSProActionInvoker.$Impl.run(this, 22923, args); },
        getSymbolValueAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 22923, args); },
        invoke: (args) => { return CSProActionInvoker.$Impl.run(this, 41927, args); },
        invokeAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 41927, args); },
        updateSymbolValue: (args) => { return CSProActionInvoker.$Impl.run(this, 17970, args); },
        updateSymbolValueAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 17970, args); }
    };

    // Application namespace
    Application = {
        getFormFile: (args) => { return CSProActionInvoker.$Impl.run(this, 49910, args); },
        getFormFileAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 49910, args); },
        getQuestionnaireContent: (args) => { return CSProActionInvoker.$Impl.run(this, 50614, args); },
        getQuestionnaireContentAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 50614, args); },
        getQuestionText: (args) => { return CSProActionInvoker.$Impl.run(this, 60242, args); },
        getQuestionTextAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 60242, args); }
    };

    // File namespace
    File = {
        readText: (args) => { return CSProActionInvoker.$Impl.run(this, 38897, args); },
        readTextAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 38897, args); },
        writeText: (args) => { return CSProActionInvoker.$Impl.run(this, 16500, args); },
        writeTextAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 16500, args); }
    };

    // Path namespace
    Path = {
        getPathInfo: (args) => { return CSProActionInvoker.$Impl.run(this, 52302, args); },
        getPathInfoAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 52302, args); },
        getSpecialPaths: (args) => { return CSProActionInvoker.$Impl.run(this, 41709, args); },
        getSpecialPathsAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 41709, args); }
    };

    // Message namespace
    Message = {
        formatText: (args) => { return CSProActionInvoker.$Impl.run(this, 31960, args); },
        formatTextAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 31960, args); },
        getText: (args) => { return CSProActionInvoker.$Impl.run(this, 449, args); },
        getTextAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 449, args); }
    };

    // Settings namespace
    Settings = {
        getValue: (args) => { return CSProActionInvoker.$Impl.run(this, 58779, args); },
        getValueAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 58779, args); },
        putValue: (args) => { return CSProActionInvoker.$Impl.run(this, 28521, args); },
        putValueAsync: (args) => { return CSProActionInvoker.$Impl.runAsync(this, 28521, args); }
    };
}

// Common CAPI functions that call CSProActionInvoker
function endRoster() {
    console.log('[CAPI] endRoster called');
    if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'cspro-action', action: 'endRoster' }, '*');
    }
}

function endGroup() {
    console.log('[CAPI] endGroup called');
    if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'cspro-action', action: 'endGroup' }, '*');
    }
}

function advance() {
    console.log('[CAPI] advance called');
    if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'cspro-action', action: 'advance' }, '*');
    }
}

function setResponse(value) {
    console.log('[CAPI] setResponse:', value);
    if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'cspro-action', action: 'setResponse', value: value }, '*');
    }
}
</script>
`;
            // Inject the shim right after <head> or at the start of the HTML
            let modifiedHtml = questionTextHtml;
            if (modifiedHtml.includes('<head>')) {
                modifiedHtml = modifiedHtml.replace('<head>', '<head>' + actionInvokerShim);
            } else if (modifiedHtml.includes('<html>')) {
                modifiedHtml = modifiedHtml.replace('<html>', '<html><head>' + actionInvokerShim + '</head>');
            } else {
                modifiedHtml = actionInvokerShim + modifiedHtml;
            }
            
            // Create a blob URL from the HTML content for the iframe
            const blob = new Blob([modifiedHtml], { type: 'text/html' });
            this._capiBlobUrl = URL.createObjectURL(blob);
            headerContent = `
                <div class="capi-question-container">
                    <iframe src="${this._capiBlobUrl}" class="capi-question-iframe"></iframe>
                </div>
            `;
        } else if (questionText) {
            // Show question text in yellow header
            headerContent = `
                <div class="capi-question-header">
                    <div class="capi-question">${questionText}</div>
                </div>
            `;
        }
        
        // Check for engine responses (from WASM engine getCurrentPage)
        // These have: code, label, imageFilename, isDiscrete, textColor
        // Also check page result fields for responses (they come with each field from getCurrentPage)
        let engineResponses = field.responses;
        if (!engineResponses && pageResult?.fields?.[0]?.responses) {
            engineResponses = pageResult.fields[0].responses;
            console.log('[MFC] Using responses from pageResult.fields[0]:', engineResponses?.length);
        }
        
        // Determine if we need to show a value set dialog
        // The dialog should ONLY show for:
        // 1. Non-roster fields (standalone fields) that need value selection
        // 2. Fields where capture type UI wasn't rendered (e.g., no inline radio/checkbox/dropdown)
        // 
        // The dialog should NOT show for:
        // 1. Roster fields (they have inline controls - radio/checkbox/dropdown)
        // 2. Fields that already have inline capture type controls
        // 3. TextBox/NumberPad fields (user types the value)
        
        const isRosterField = field.roster || 
            (field.indexes && field.indexes.length > 0 && field.indexes[0] > 0);
        
        // Get capture type (normalize to number)
        let captureType = field.captureType ?? 0;
        if (typeof captureType === 'string') {
            const ctMap = { 'TextBox': 0, 'RadioButton': 1, 'CheckBox': 2, 'DropDown': 3, 'ComboBox': 4 };
            captureType = ctMap[captureType] ?? 0;
        }
        
        // Check if the field element already has inline controls rendered
        const fieldElement = this.$.formContainer?.querySelector(`[data-field-name="${field.name}"]`);
        const hasInlineControls = fieldElement && (
            fieldElement.querySelector('input[type="radio"]') ||
            fieldElement.querySelector('input[type="checkbox"]') ||
            fieldElement.querySelector('select') ||
            fieldElement.classList.contains('form-field-radio-group') ||
            fieldElement.classList.contains('form-field-checkbox-group') ||
            fieldElement.classList.contains('form-field-dropdown')
        );
        
        // Get display mode preference (inline vs dialog)
        const displayMode = this._getCaptureDisplayMode();
        
        // For inline mode with RadioButton/CheckBox, we want inline controls - NOT dialog
        // The dialog should only show when:
        // - displayMode is 'dialog', OR
        // - It's DropDown/ComboBox (these always need popup regardless of mode)
        const CT = CSEntryMFCView.CAPTURE_TYPES;
        const isDropDownOrCombo = captureType === CT.DropDown || captureType === CT.ComboBox;
        const isRadioOrCheckbox = captureType === CT.RadioButton || captureType === CT.CheckBox;
        const wantsDialogMode = displayMode === 'dialog';
        
        // Show value set dialog only if:
        // - Has responses AND
        // - NOT a roster field AND
        // - NOT has inline controls already rendered AND
        // - Capture type suggests popup selection is needed (not TextBox/NumberPad) AND
        // - Either user wants dialog mode, OR it's DropDown/ComboBox (always popup)
        // Note: For RadioButton/CheckBox with inline mode, we skip the dialog
        const shouldShowDialog = engineResponses && 
            engineResponses.length > 0 && 
            !isRosterField && 
            !hasInlineControls &&
            captureType !== 0 && // Not TextBox
            captureType !== 5 && // Not NumberPad
            (wantsDialogMode || isDropDownOrCombo); // Only dialog mode or DropDown/ComboBox
        
        if (shouldShowDialog) {
            console.log('[MFC] Showing value set dialog for field:', field.name, 'responses:', engineResponses.length, 'displayMode:', displayMode);
            this._showValueSetDialog(field, engineResponses);
        } else {
            // Close any existing value set dialog when moving to a field that doesn't need one
            // This ensures the dialog doesn't persist when advancing to a non-dialog field
            if (this.$.dialogOverlay?.style.display === 'block') {
                console.log('[MFC] Closing existing dialog - field does not need dialog');
                this._closeDialog();
            }
            if (engineResponses && engineResponses.length > 0) {
                console.log('[MFC] Responses available but not showing dialog:', field.name, 
                            'isRoster:', isRosterField, 'hasInline:', hasInlineControls, 'captureType:', captureType, 'displayMode:', displayMode);
            }
        }
        
        // Show CAPI panel if we have question text (header content)
        // NOTE: Responses/value sets are now shown in a separate dialog, not in the CAPI panel
        if (headerContent) {
            this.$.capiPanel.classList.add('visible');
            this.$.capiPanel.innerHTML = headerContent;
        } else {
            this.$.capiPanel.classList.remove('visible');
        }
    }
    
    /**
     * Handle selection of a CAPI response
     * Works for both regular form fields and roster cells
     * CRITICAL: Always use engine advanceField to enforce CSPro logic
     */
    async _selectCAPIResponse(fieldName, code) {
        console.log('[MFC] _selectCAPIResponse:', fieldName, 'code:', code);
        
        // For roster fields, we need to consider the current occurrence (row index)
        let element = null;
        
        // Determine if this is a roster field based on currentField data from engine
        const isRosterField = this.currentField && 
            (this.currentField.roster || (this.currentField.indexes && this.currentField.indexes[0] > 0));
        
        if (isRosterField) {
            // This is a roster field - find by field name AND row index
            const rowIdx = (this.currentField.indexes?.[0] || this.currentField.occurrence || 1) - 1;
            element = this.$.formContainer.querySelector(
                `[data-field-name="${fieldName}"][data-row-index="${rowIdx}"]`
            );
        }
        
        // If not found by row index, or not a roster field, try finding by field name only
        if (!element) {
            element = this.$.formContainer.querySelector(`[data-field-name="${fieldName}"]`);
        }
        
        if (!element) {
            console.log(`[MFC] _selectCAPIResponse: Element not found for ${fieldName}, advancing with value`);
            // Even if element not found, still advance with the selected value through engine
            await this._advanceWithValue(code);
            return;
        }
        
        // Visually update the field element before advancing
        // This provides immediate feedback to the user
        if (element.classList.contains('form-field-radio-group')) {
            const radio = element.querySelector(`input[value="${code}"]`);
            if (radio) radio.checked = true;
        } else if (element.classList.contains('form-field-checkbox-group')) {
            const checkbox = element.querySelector(`input[value="${code}"]`);
            if (checkbox) checkbox.checked = !checkbox.checked;
        } else if (element.classList.contains('form-field-dropdown') || element.tagName === 'SELECT') {
            element.value = code;
        } else if (element.classList.contains('roster-field-container')) {
            // Roster cell - find the actual input and set value visually
            const input = element.querySelector('input:not([type="radio"]):not([type="checkbox"])') || 
                          element.querySelector('select');
            if (input) {
                input.value = code;
            }
            // For radio/checkbox in roster, check the matching option
            const radioOpt = element.querySelector(`input[type="radio"][value="${code}"]`);
            if (radioOpt) radioOpt.checked = true;
            const checkOpt = element.querySelector(`input[type="checkbox"][value="${code}"]`);
            if (checkOpt) checkOpt.checked = true;
        } else if (element.tagName === 'INPUT') {
            element.value = code;
        }
        
        // ALWAYS advance through the engine to enforce CSPro logic
        // This ensures postproc, errmsg, skip patterns, etc. are executed
        console.log('[MFC] _selectCAPIResponse: Advancing with value through engine');
        await this._advanceWithValue(code);
    }

    _buildCaseTree() {
        this.$.treeContent.innerHTML = '';
        if (!this.currentForm) return;
        
        const root = this._createTreeNode('QUESTIONNAIRE', 'level', true);
        const children = root.querySelector('.tree-children');
        
        this.currentForm.fields?.forEach(field => {
            children.appendChild(this._createTreeNode(field.label, 'field', false, field.name));
        });
        
        root.classList.add('expanded');
        this.$.treeContent.appendChild(root);
    }

    _createTreeNode(label, type, hasChildren, fieldName = null) {
        const node = document.createElement('div');
        node.className = 'tree-node';
        if (fieldName) node.dataset.fieldName = fieldName;
        
        const header = document.createElement('div');
        header.className = 'tree-node-header';
        
        const toggle = document.createElement('span');
        toggle.className = 'tree-toggle' + (hasChildren ? '' : ' empty');
        header.appendChild(toggle);
        
        const icon = document.createElement('span');
        icon.className = 'tree-icon';
        icon.textContent = type === 'level' ? '' : '';
        header.appendChild(icon);
        
        const labelEl = document.createElement('span');
        labelEl.className = 'tree-label';
        labelEl.textContent = label;
        header.appendChild(labelEl);
        
        if (type === 'field') {
            const value = document.createElement('span');
            value.className = 'tree-value';
            value.dataset.fieldName = fieldName;
            header.appendChild(value);
        }
        
        header.addEventListener('click', () => {
            if (hasChildren) node.classList.toggle('expanded');
            if (fieldName) this.goToField(fieldName);
        });
        
        node.appendChild(header);
        
        if (hasChildren) {
            const childrenEl = document.createElement('div');
            childrenEl.className = 'tree-children';
            node.appendChild(childrenEl);
        }
        
        return node;
    }

    _highlightTreeField(fieldName) {
        this.$.treeContent.querySelectorAll('.tree-node-header.selected').forEach(el => {
            el.classList.remove('selected');
        });
        const node = this.$.treeContent.querySelector(`[data-field-name="${fieldName}"]`);
        if (node) {
            node.querySelector('.tree-node-header').classList.add('selected');
        }
    }

    _updateTreeValue(fieldName, value) {
        const el = this.$.treeContent.querySelector(`.tree-value[data-field-name="${fieldName}"]`);
        if (el) el.textContent = value;
    }

    _clearFields() {
        this.$.formContainer.querySelectorAll('.form-field-input').forEach(input => {
            input.value = '';
            input.classList.remove('visited', 'error');
        });
    }

    _collectValues() {
        const values = {};
        this.$.formContainer.querySelectorAll('.form-field-input').forEach(input => {
            values[input.dataset.fieldName] = input.value;
        });
        return values;
    }

    _updateStatus(field = '', occ = '', mode = null) {
        this.$.statusField.textContent = field || 'Ready';
        this.$.statusOcc.textContent = occ;
        if (mode) this.$.statusMode.textContent = mode;
        
        if (this.currentForm?.fields) {
            let filled = 0;
            this.$.formContainer.querySelectorAll('.form-field-input').forEach(input => {
                if (input.value) filled++;
            });
            const total = this.currentForm.fields.length;
            this.$.statusProgress.textContent = `${filled}/${total} (${Math.round(filled/total*100)}%)`;
        }
    }

    _pageDown() {
        const idx = this.currentApp.forms.indexOf(this.currentForm);
        if (idx < this.currentApp.forms.length - 1) {
            this._switchForm(idx + 1);
        }
    }

    _pageUp() {
        const idx = this.currentApp.forms.indexOf(this.currentForm);
        if (idx > 0) {
            this._switchForm(idx - 1);
        }
    }

    // UI Helpers
    _showLoading(msg) {
        this.$.formContainer.innerHTML = `<div class="welcome-message"><p> ${msg}</p></div>`;
    }

    _hideLoading() {
        // Loading hides when form renders
    }

    _showMessage(msg) {
        alert(msg); // TODO: Better modal
    }

    _showError(msg) {
        alert('Error: ' + msg);
    }

    async _confirm(title, msg) {
        return confirm(`${title}\n\n${msg}`);
    }

    _showOpenDialog() {
        // Use the new app loader dialog
        this._showAppLoader();
    }

    _showModifyDialog() {
        this._showMessage('Select a case to modify');
    }

    _showFindDialog() {
        this._showMessage('Find case dialog');
    }

    _showGoToDialog() {
        if (!this.currentForm?.fields) return;
        const name = prompt('Enter field name:', this.currentField?.name || '');
        if (name) this.goToField(name);
    }

    _showNoteDialog() {
        this._showMessage('Field note dialog');
    }

    _applyTheme(theme) {
        // Theme application logic
    }
}

// Register the component
customElements.define('csentry-mfc-view', CSEntryMFCView);

export default CSEntryMFCView;
